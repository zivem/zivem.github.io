[{"categories":null,"content":"JVM基础 ","date":"2021-02-12","objectID":"/jvm/:0:0","tags":null,"title":"JVM基础","uri":"/jvm/"},{"categories":null,"content":"如何避免OutOfMemory ","date":"2021-02-12","objectID":"/jvm/:1:0","tags":null,"title":"JVM基础","uri":"/jvm/"},{"categories":null,"content":"hotspot 为了避免由新生代对象晋升道老年代，导致老年代空间不足的情况 在进行Minor GC时，判断之前晋升平均大小，大于老年代剩余空间，直接触发Full GC 例如：第一次触发MinorGc，有6MB对象晋升，再次MinorGC，老年代剩余空间小于6MB，则直接Full GC. 新生代 采用PSGC，在Minor GC，检查老年代剩余空间，小于6MB，触发对老年代回收。 除此之外，使用RMI进行RPC管理Sun JDK，默认情况下会一小时执行一次Full GC 可通过 java-Dsun.rmi.dgc.client.gcInterval=3600000设置间隔时间 -XX:+DisableExplicitGC来禁止RMI调用System.gc ","date":"2021-02-12","objectID":"/jvm/:1:1","tags":null,"title":"JVM基础","uri":"/jvm/"},{"categories":null,"content":"Java虚拟机是什么？Java为什么被称作是“平台无关的编程语言”？ Java虚拟机是一个可以执行Java字节码的虚拟机进程。 Java源文件被编译成能被Java虚拟机执行的字节码文件。 Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。 Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特 性。 ","date":"2021-02-12","objectID":"/jvm/:2:0","tags":null,"title":"JVM基础","uri":"/jvm/"},{"categories":null,"content":"对象分配规则 对象优先分配在Eden区，没有足够空间，则执行一次Minor GC 大对象直接进入老年代，（大对象指需要大量连续内存空间的对象），这样避免Eden区和俩个Survivor区之间发生大量的内存拷贝（新生代采用的复制算法进行内存回收） 长期存活对象进入Surivivor区，经历两次Minor GC 就会进入老年代 动态判断对象年龄，若Survivor中相同年龄的所有对象，大小综合大于Survivor空间一般，年龄大于或等于该年龄的对象可以直接进入老年代 空间分配担保。Minor GC，JVM计算Survivor区晋升老年代的对象平均大小，大于老年代剩余空间大小，进行Full GC. 小于时，HandlePromotionFailre = true ，只进行Monitor GC，false则进行Full GC。 ","date":"2021-02-12","objectID":"/jvm/:3:0","tags":null,"title":"JVM基础","uri":"/jvm/"},{"categories":null,"content":"JVM加载class原理机制 jvm中类的装在由类加载器classLoader和其子类实现 类的加载过程： 加载、连接（验证、准备和解析）和初始化。 加载 类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。 连接 加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。 初始化 最后JVM对类进行初始化，包括： 1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类； 2)如果类中存在初始化语句，就依次执行这些初始化语句。 类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（Extension）、系统加载器（System）和用户自定义类加载器（java.lang.ClassLoader的子类）。 Bootstrap：一般用本地代码实现，负责加载JVM基础核心类库（rt.jar）； Extension：从java.ext.dirs系统属性所指定的目录中加载类库，它的父加载器是Bootstrap； System：又叫应用类加载器，其父类是Extension。它是应用最广泛的类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中记载类，是用户自定义加载器的默认父加载器。 ","date":"2021-02-12","objectID":"/jvm/:4:0","tags":null,"title":"JVM基础","uri":"/jvm/"},{"categories":null,"content":"Java对象创建过程 1.JVM遇到一条新建对象的指令时首先去检查这个指令的参数是否能在常量池中定义到一个类的符号引用。然后加载这个类 2.为对象分配内存。一种办法“指针碰撞”、一种办法“空闲列表”，最终常用的办法“本地线程缓冲分配(TLAB)” 3.将除对象头外的对象内存空间初始化为0 4.对对象头进行必要设置 ","date":"2021-02-12","objectID":"/jvm/:5:0","tags":null,"title":"JVM基础","uri":"/jvm/"},{"categories":null,"content":"类的生命周期 类的生命周期 加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象 连接，连接又包含三块内容：验证、准备、初始化。 1）验证，文件格式、元数据、字节码、符号引用验证； 2）准备，为类的静态变量分配内存，并将其初始化为默认值； 3）解析，把类中的符号引用转换为直接引用 初始化，为类的静态变量赋予正确的初始值 使用，new出对象程序中使用 卸载，执行垃圾回收 ","date":"2021-02-12","objectID":"/jvm/:6:0","tags":null,"title":"JVM基础","uri":"/jvm/"},{"categories":null,"content":"Java对象结构 Java对象由三个部分组成：对象头、实例数据、对齐填充。 java对象结构 对象头： 第一部分存储对象自身的运行时数据：哈希码、GC分代年龄、锁标识状态、线程持有的锁、偏向线程ID（一般占32/64 bit）。 第二部分是指针类型，指向对象的类元数据类型（即对象代表哪个类）。如果是数组对象，则对象头中还有一部分用来记录数组长度。 实例数据：用来存储对象真正的有效信息（包括父类继承下来的和自己定义的） 对齐填充：JVM要求对象起始地址必须是8字节的整数倍（8字节对齐） ","date":"2021-02-12","objectID":"/jvm/:7:0","tags":null,"title":"JVM基础","uri":"/jvm/"},{"categories":null,"content":"JVM永久代会发生垃圾回收吗？ 有垃圾回收，只是条件难以达到，主要回收：常量池中废弃的常量和不在使用的类型(类) 但是判断一个类型是否属于“不在被使用的类”的条件就非常苛刻了。需要同时满足以下三个条件： 1、该类的所有实例都已经被回收，也就是堆中不存在该类及其任何派生子类的实例。 2、加载该类的类加载器已经被回收，这个条件通常是很难达到的。 3、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 ","date":"2021-02-12","objectID":"/jvm/:8:0","tags":null,"title":"JVM基础","uri":"/jvm/"},{"categories":null,"content":"常用命令 jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。 jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟 机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。 jmap，JVM Memory Map命令用于生成heap dump文件 jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内 置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看 jstack，用于生成java虚拟机当前时刻的线程快照。 jinfo，JVM Confifiguration info 这个命令作用是实时查看和调整虚拟机运行参数。 ","date":"2021-02-12","objectID":"/jvm/:9:0","tags":null,"title":"JVM基础","uri":"/jvm/"},{"categories":null,"content":"性能调优参数 设定堆内存大小 -Xmx：堆内存最大限制。 设定新生代大小。 新生代不宜太小，否则会有大量对象涌入老年代 -XX:NewSize：新生代大小 -XX:NewRatio 新生代和老生代占比 -XX:SurvivorRatio：伊甸园空间和幸存者空间的占比 设定垃圾回收器 年轻代用 -XX:+UseParNewGC 年老代用-XX:+UseConcMarkSweepGC ","date":"2021-02-12","objectID":"/jvm/:10:0","tags":null,"title":"JVM基础","uri":"/jvm/"},{"categories":null,"content":"对象一定分配在堆上吗？什么是逃逸分析？ 「对象一定分配在堆中吗？」 不一定的，JVM通过**「逃逸分析」，那些逃不出方法的对象会在栈上分配。** 「什么是逃逸分析？」 逃逸分析(Escape Analysis)，是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。 通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围，从而决定是否要将这个对象分配到堆上。 逃逸分析是指分析指针动态范围的方法，它同编译器优化原理的指针分析和外形分析相关联。当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他方法或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。 通俗点讲，如果一个对象的指针被多个方法或者线程引用时，那么我们就称这个对象的指针发生了逃逸。 「逃逸分析的好处」 栈上分配，可以降低垃圾收集器运行的频率。 同步消除，如果发现某个对象只能从一个线程可访问，那么在这个对象上的操作可以不需要同步。 标量替换，把对象分解成一个个基本类型，并且内存分配不再是分配在堆上，而是分配在栈上。这样的好处有， 一、减少内存使用，因为不用生成对象头。 二、程序内存回收效率高，并且GC频率也会减少。 ","date":"2021-02-12","objectID":"/jvm/:11:0","tags":null,"title":"JVM基础","uri":"/jvm/"},{"categories":null,"content":"虚拟机为什么使用元空间替换了永久代？ ","date":"2021-02-12","objectID":"/jvm/:12:0","tags":null,"title":"JVM基础","uri":"/jvm/"},{"categories":null,"content":"「什么是元空间？什么是永久代？为什么用元空间代替永久代？」 我们先回顾一下**「方法区」**吧,看 看虚拟机运行时数据内存图，如下: 虚拟机运行时数据内存 方法区和堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。 ","date":"2021-02-12","objectID":"/jvm/:12:1","tags":null,"title":"JVM基础","uri":"/jvm/"},{"categories":null,"content":"「什么是永久代？它和方法区有什么关系呢？」 如果在HotSpot虚拟机上开发、部署，很多程序员都把方法区称作永久代。可以说方法区是规范，永久代是Hotspot针对该规范进行的实现。在Java7及以前的版本，方法区都是永久代实现的。 「什么是元空间？它和方法区有什么关系呢？」 对于Java8，HotSpots取消了永久代，取而代之的是元空间(Metaspace)。换句话说，就是方法区还是在的，只是实现变了，从永久代变为元空间了。 「为什么使用元空间替换了永久代？」 永久代的方法区，和堆使用的物理内存是连续的。 **「永久代」**是通过以下这两个参数配置大小的~ -XX:PremSize：设置永久代的初始大小 -XX:MaxPermSize: 设置永久代的最大值，默认是64M 对于**「永久代」，如果动态生成很多class的话，就很可能出现「java.lang.OutOfMemoryError:PermGen space 错误」**，因为永久代空间配置有限嘛。最典型的场景是，在web开发比较多jsp页面的时候。 JDK8之后，方法区存在于元空间(Metaspace)。物理内存不再与堆连续，而是直接存在于本地内存中，理论上机器**「内存有多大，元空间就有多大」**。 可以通过以下的参数来设置元空间的大小： -XX:MetaspaceSize，初始空间大小，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整： 如果释放了大量的空间，就适当降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize时，适当提高该值。 -XX:MaxMetaspaceSize，最大空间，默认是没有限制的。 -XX:MinMetaspaceFreeRatio，在GC之后，最小的Metaspace剩余空间容量的百分比，减少为分配空间所导致的垃圾收集 -XX:MaxMetaspaceFreeRatio，在GC之后，最大的Metaspace剩余空间容量的百分比，减少为释放空间所导致的垃圾收集 ","date":"2021-02-12","objectID":"/jvm/:12:2","tags":null,"title":"JVM基础","uri":"/jvm/"},{"categories":null,"content":"「所以，为什么使用元空间替换永久代？」 表面上看是为了避免OOM异常。因为通常使用PermSize和MaxPermSize设置永久代的大小就 决定了永久代的上限，但是不是总能知道应该设置为多大合适, 如果使用默认值很容易遇到OOM错误。 当使用元空间时，可以加载多少类的元数据就不再由MaxPermSize控制, 而由系统的实际可用空间来控制啦。 ","date":"2021-02-12","objectID":"/jvm/:12:3","tags":null,"title":"JVM基础","uri":"/jvm/"},{"categories":null,"content":"什么是Stop The World ?什么是OopMap？什么是安全点？ ","date":"2021-02-12","objectID":"/jvm/:13:0","tags":null,"title":"JVM基础","uri":"/jvm/"},{"categories":null,"content":"Stop The World 进行垃圾回收的过程中，会涉及对象的移动。为了保证对象引用更新的正确性，必须暂停所有的用户线程，像这样的停顿，虚拟机设计者形象描述为**「top The World」**。也简称为STW。 ","date":"2021-02-12","objectID":"/jvm/:13:1","tags":null,"title":"JVM基础","uri":"/jvm/"},{"categories":null,"content":"OopMap 在HotSpot中，有个数据结构（映射表）称为**「OopMap」**。一旦类加载动作完成的时候，HotSpot就会把对象内什么偏移量上是什么类型的数据计算出来，记录到OopMap。 在即时编译过程中，也会在**「特定的位置」**生成 OopMap，记录下栈上和寄存器里哪些位置是引用。 这些特定的位置主要在： 循环的末尾（非 counted 循环） 方法临返回前 / 调用方法的call指令后 可能抛异常的位置 这些位置就叫作**「安全点(safepoint)。」** 用户程序执行时并非在代码指令流的任意位置都能够在停顿下来开始垃圾收集，而是必须是执行到安全点才能够暂停。 ","date":"2021-02-12","objectID":"/jvm/:13:2","tags":null,"title":"JVM基础","uri":"/jvm/"},{"categories":null,"content":"Zookeeper ","date":"2020-07-28","objectID":"/zookeeper/:0:0","tags":["ZooKeeper"],"title":"ZooKeeper基本理解","uri":"/zookeeper/"},{"categories":null,"content":"简介 ","date":"2020-07-28","objectID":"/zookeeper/:1:0","tags":["ZooKeeper"],"title":"ZooKeeper基本理解","uri":"/zookeeper/"},{"categories":null,"content":"使用场景 ZooKeeper最主要的使用场景是分布式系统的分布式协同服务。 ","date":"2020-07-28","objectID":"/zookeeper/:1:1","tags":["ZooKeeper"],"title":"ZooKeeper基本理解","uri":"/zookeeper/"},{"categories":null,"content":"分布式系统服务进程通信方式 通过网络进行信息共享 通过共享存储 ZooKeeoer对分布式系统的协调，使用的是第二种方式，共享存储。 ","date":"2020-07-28","objectID":"/zookeeper/:1:2","tags":["ZooKeeper"],"title":"ZooKeeper基本理解","uri":"/zookeeper/"},{"categories":null,"content":"基本概念 ZooKeeper是一个开源的分布式协调服务，设计目标是将哪些复杂的且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一些简单的接口提供给用户使用。 ZooKeeper是一个典型的分布式数据一致性的解决方案。 基于它实现数据订阅/发布、负载均衡、命名服务、集群管理、分布式锁喝分布式队列等功能。 集群 分布式系统：Master/Slave模式，主备模式 ZooKeeper： Leader:通过选举选定，为客户端提供读和写服务 Follower：读服务 Observer：读服务，不参与选举 会话 ZooKeeper默认端口2181. 客户端启动的时候，首先会与服务器建立一个TCP连接，从第一次建立开始，客户端生命周期开始，客户端能够心跳检测与服务器保持有效的会话，也能向Zookeeper服务器发送请求并接受响应，同时还能够通过该连接接受来自服务器的Watch事件通知。 数据节点Znode 构成集群的机器，机器节点； 数据模型中的数据单元，数据节点-Znode。ZooKeeper所有数据存储在内存中，数据模型是一棵树，通过斜杆进行分割路径。 版本 对于每个Znode，ZooKeeper都会为其维护一个叫做Stat的数据结构，记录了Znode的三个数据版本 version当前版本 cversion当前znode子节点的版本 aversion当前znode的ACL版本，access control list 权限控制 Watcher事件监听器 Watcher，重要特性。zookeeper允许再指定节点注册watcher，并在一些特定事件触发 ACL Zookeeper􏳔􏰉采用ACL􏴦Access ControlLists􏴧􏵣􏵤􏱆􏲴􏰪􏵥􏱁􏵦􏵠􏰌􏲢􏰜􏰝􏲧􏱭􏰳􏵧􏲾􏵥􏱁􏰞策略进行权限控制，以下五种权限： CREATE􏰞􏵨􏴍􏵓􏳴􏱎􏰇􏵥􏱁􏰘:创建子节点的权限 READ􏰞􏵩􏵪􏳴􏱎􏴤􏴥􏳵􏵓􏳴􏱎􏱲􏵫􏰇􏵥􏱁􏰘:获取节点数据和子节点列表的权限 WRITE􏰞􏵬􏵭􏳴􏱎􏴤􏴥􏰇􏵥􏱁:更新节点数据权限 DELETE􏰞􏵮􏵯􏵓􏳴􏱎􏰇􏵥􏱁􏰘:删除子节点权限 ADMIN􏰞􏱧􏵰:设置节点􏳴􏱎ACL􏰇􏵥􏱁􏰘权限 􏲢􏱱􏳜􏰆􏵛􏵱􏰇􏰍􏰌CREATE􏳵和Delete权限都是针对子节点的权限控制􏱁􏳍􏰍􏵲􏲌􏵓􏳴􏱎􏰇􏵥􏱁􏵦􏵠 ","date":"2020-07-28","objectID":"/zookeeper/:1:3","tags":["ZooKeeper"],"title":"ZooKeeper基本理解","uri":"/zookeeper/"},{"categories":null,"content":"基本使用 ","date":"2020-07-28","objectID":"/zookeeper/:2:0","tags":["ZooKeeper"],"title":"ZooKeeper基本理解","uri":"/zookeeper/"},{"categories":null,"content":"ZNode类型 持久性节点 临时性节点 顺序性节点 通过组合可以生成四种节点类型： 持久节点 节点创建后会一直存在服务器，直到删除操作主动清除 持久顺序节点 持久性节点额外的特性，节点后就啊上一个数字后缀 临时节点 会被自动清理的节点，客户端会话结束，节点会被删除，临时节点不能创建子节点 临时顺序节点 临时节点的顺序性，添加数字后缀 ","date":"2020-07-28","objectID":"/zookeeper/:2:1","tags":["ZooKeeper"],"title":"ZooKeeper基本理解","uri":"/zookeeper/"},{"categories":null,"content":"事务ID 事务是指能够改变zookeeper服务器状态的操作，称之为事务操作或更新操作，一般包括节点创建与删除，数据节点内容更新等操作。 每一个事务请求，都会为其分配一个全局唯一的事务ID，用ZXID表示。通常是一个63位数字。每个ZXID对应一次更新操作。 ","date":"2020-07-28","objectID":"/zookeeper/:2:2","tags":["ZooKeeper"],"title":"ZooKeeper基本理解","uri":"/zookeeper/"},{"categories":null,"content":"ZNode状态信息 节点数据内容 quota节点数据 状态信息 其它状态信息 ","date":"2020-07-28","objectID":"/zookeeper/:2:3","tags":["ZooKeeper"],"title":"ZooKeeper基本理解","uri":"/zookeeper/"},{"categories":null,"content":"Watcher数据变更通知 分布式数据的发布/订阅功能 ","date":"2020-07-28","objectID":"/zookeeper/:2:4","tags":["ZooKeeper"],"title":"ZooKeeper基本理解","uri":"/zookeeper/"},{"categories":null,"content":"ACL保障数据安全 ","date":"2020-07-28","objectID":"/zookeeper/:2:5","tags":["ZooKeeper"],"title":"ZooKeeper基本理解","uri":"/zookeeper/"},{"categories":null,"content":"应用 ","date":"2020-07-28","objectID":"/zookeeper/:3:0","tags":["ZooKeeper"],"title":"ZooKeeper基本理解","uri":"/zookeeper/"},{"categories":null,"content":"数据发布/订阅 数据发布订阅就是所谓的配置中心，发布者将数据发布到zookeeper的节点上，供订阅者进行数据订阅，今儿达到动态获取数据的目的，实现配置信息的集中式管理和数据的动态更新。 设计模式 推Push模式，服务端主动将数据更新发送给所有订阅的客户端 拉Pull模式，一般客户端主动发起请求获取最新数据，采用定时轮询拉取方式 指定节点注册watcher监听，发生变更通知所有订阅的客户端 需要具备以下特性： 数据量小； 数据内容运行时发生动态变化； 集群中各机器共享，配置一致。 ","date":"2020-07-28","objectID":"/zookeeper/:3:1","tags":["ZooKeeper"],"title":"ZooKeeper基本理解","uri":"/zookeeper/"},{"categories":null,"content":"命名服务 分布式全局唯一ID分配机制 基本步骤： 所有客户端都会根据自己的任务类型，在指定类型的任务下通过调用crate（）接口创建一个顺序节点； 节点创建完毕，crate（）接口会返回一个完整的节点名，例如：“job-000000003”； 客户端拿到返回值，拼接type类型，就可以做为一个全局唯一的ID ","date":"2020-07-28","objectID":"/zookeeper/:3:2","tags":["ZooKeeper"],"title":"ZooKeeper基本理解","uri":"/zookeeper/"},{"categories":null,"content":"集群管理 zookeeper两大特性： 客户端对数据节点watcher监听，数据节点修改，服务器向订阅的客户端发送变更通知 创建临时节点，一旦客户端与服务器之间的会话失效，临时节点会被删除 利用这两个特性，可以实现集群机器存活监控系统。 分布式日志手机系统 核心工作：手机不同机器上的系统日志。 步骤： 注册收集器机器 创建一个节点做为收集器跟节点，例如/logs/collector,每台机器启动时在收集器节点下创建自己的节点 任务分发 系统根据收集器节点下子节点的个数，将日志源机器分成对应的若干组，将分组后的机器列表分别写到子节点上，这样每个收集器都能从自己的节点上获取日志源机器列表，进而进行日志收集工作 状态汇报 动态分配 ","date":"2020-07-28","objectID":"/zookeeper/:3:3","tags":["ZooKeeper"],"title":"ZooKeeper基本理解","uri":"/zookeeper/"},{"categories":null,"content":"分布式锁 分布式锁是控制分布式系统之间同步访问共享资源的一种方式。 排它锁 简称X锁，又称写锁或独占锁，是一种基本的锁类型。事务对数据对象加上了排它锁，整个加锁期间，只允许该事务对数据对象进行读取和更新操作，其他任何事务搜不能对这个数据对象做任何类型的操作。 定义锁 数据节点表示一个锁 获取锁 调用create（）接口创建临时自己诶点，zookeeper会保证所有的客户端中，最终只有一个客户端能够创建成功，那么就可以认为该客户端获取了锁。未获取锁的在lock节点注册watcher监听。 释放锁 两种方式： 锁是临时节点，所以客户端届起宕机，节点会被移除，就会释放锁 执行正常业务逻辑后，主动删除节点。 共享锁 简称S锁，又称为读锁。 如果事务A对对象O加共享锁，当前事务职能对O进行读操作，其它事务也只能对这个数据对象家共享锁。 定义锁 通过数据节点表示一个锁，临时顺序节点 获取锁 获取共享锁时，都会创建一个临时顺序节点。 释放锁 和独占锁一致 ","date":"2020-07-28","objectID":"/zookeeper/:3:4","tags":["ZooKeeper"],"title":"ZooKeeper基本理解","uri":"/zookeeper/"},{"categories":null,"content":"分布式队列 分类 FIFO先进先出 创建临时顺序节点 执行顺序： 获取所有元素 确定自己的节点序号在子节点中的顺序 如果自己的序号不是最小，那么需要等待，同时比自己序号小的最后一个节点注册watcher监听 接收到watcher通知，重复第一步 Barrier：分布式屏障 指分布式系统之间的一个协调条件，规定了一个队列元素必须都集聚后才能统一进行安排，否则一直等待。 ","date":"2020-07-28","objectID":"/zookeeper/:3:5","tags":["ZooKeeper"],"title":"ZooKeeper基本理解","uri":"/zookeeper/"},{"categories":null,"content":"领域驱动模型DDD ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:0:0","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"定义 在开发前，通常需要进行大量的业务知识梳理，而后到达软件设计的层面，最后才是开发。而在业务知识梳理的过程中，我们必然会形成某个领域知识，根据领域知识来一步步驱动软件设计，就是领域驱动设计的基本概念。而领域驱动设计的核心就在于建立正确的领域驱动模型。 ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:1:0","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"设计思想 业务逻辑不再集中在几个大型的类上，而是由大量相对小的领域对象(类)组成，这些类具备自己的状态和行为，每个类是相对完整的独立体，并与现实领域的业务对象映射。领域模型就是由这样许多的细粒度的类组成。 ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:2:0","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"设计阶段 1、以一种领域专家、设计人员、开发人员都能理解的通用语言作为相互交流的工具，在交流的过程中发现领域概念，然后将这些概念设计成一个领域模型； 2、由领域模型驱动软件设计，用代码来实现该领域模型； ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:3:0","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"传统模型 对象是数据的载体，只有简单的getter/setter方法，没有行为。 以数据为中心，以数据库ER设计作驱动 贫血模式 业务逻辑都是写在Service中的，WmActPoi充其量只是个数据载体，没有任何行为，是一种贫血模型 业务逻辑复杂了，业务逻辑、状态会散落到在大量方法中，原本的代码意图会渐渐不明确，我们将这种情况称为由贫血症引起的失忆症 特点 a. 以数据库为中心 b. 贫血模型 c. 业务逻辑散落在大量的方法中 d. 当系统越来越复杂时，开发时间指数增长，维护成本很高 ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:4:0","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"常见模型  DO(Data Object):此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。  DTO(Data Transfer Object):数据传输对象，Service 或 Manager 向外传输的对象。  BO(Business Object):业务对象，由 Service 层输出的封装业务逻辑的对象。  AO(ApplicationObject):应用对象，在Web层与Service层之间抽象的复用对象模型， 极为贴近展示层，复用度不高。  VO(View Object):显示层对象，通常是 Web 向模板渲染引擎层传输的对象。  Query:数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。  POJO：简单无规则java对象 纯的传统意义的java对象，最基本的Java Bean只有属性加上属性的get和set方法可以额转化为PO、DTO、VO；比如POJO在传输过程中就是DTO  PO：持久层对象 是ORM(Objevt Relational Mapping)框架中Entity，PO属性和数据库中表的字段形成一一对应关系 VO和PO，都是属性加上属性的get和set方法；表面看没什么不同，但代表的含义是完全不同的 ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:5:0","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"架构解决方案 ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:6:0","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"用户界面、表现层 负责向用户战羡信息以及解释用户命令 ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:6:1","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"应用层 很薄的一层，用来协调应用的活动，它不包含业务逻辑，他不保留业务对象的状态。但它保有应用任务的进度状态 ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:6:2","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"领域层 本层包含关于领域的信息。这是业务软件核心的所在。在这里保留业务对象的状态，对业务对象和他们状态的持久化被委托给了基础设施层 ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:6:3","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"基础设施层 本层作为其它层的支撑库存在。它提供了层间的通信，实现对业务对象的持久化，包含对用户界面层的支撑库等作用 ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:6:4","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"要素 ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:7:0","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"实体(Entity) 领域模型的基本元素 实体应该具有唯一的标识符 ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:7:1","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"值对象(Value Object) 没有唯一标识符的实体 领域模型中是可以被共享的，他们应该是“不可变的”（只读的） 需要用到值对象时，可以将它的副本作为参数传递。 ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:7:2","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"服务(Services) 领域中有一些行为是无法映射到具体的对象中的，我们也不能强行将其放入在某一个模型对象中，而将其单独作为一个方法又没有地方，此时就需要服务 服务是无状态的，对象是有状态的。所谓状态，就是对象的基本属性。服务本身也是对象，但它却没有属性（只有行为），因此说是无状态的。 目的就是为领域提供简单的方法 特点 a)服务中体现的行为一定是不属于任何实体和值对象的，但它属于领域模型的范围内 b)服务的行为一定涉及其他多个对象 c)服务的操作是无状态的 ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:7:3","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"模块(Moudles) 为了组织统一的模型概念来达到减少复杂性的目的 模块可以提高代码质量和可维护性 模块应当有对外的统一接口供其他模块调用 ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:7:4","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"聚合(Aggregates) 聚合表示一组领域对象(包括实体和值对象)，用来表述一个完整的领域概念。而每个聚合都有一个根实体，这个根实体又叫做聚合根。 ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:7:5","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"工厂(Factory) 帮助封装复杂的对象创建过程 ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:7:6","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"资源库Repositories 资源库的是封装所有获取对象引用所需的逻辑 Repository 接口应当采用领域通用语言 DAO是比Repository更低的一层，包含了如何从数据库中提取数据的代码。 Repository把ORM框架与领域模型隔离，对外隐藏封装了数据访问机制。 ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:7:7","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"持续集成与模型一致性 ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:8:0","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"规约(Factory) 规约是一种布尔断言。 规约是业务规则的 部分 理论上规约类中的方法只有个：isSatisfiedBy(Object obj)。 规约用来测试对象是否满足某种条件，用来进行对象查询，也可以作为某个对象的创建条件。 ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:8:1","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"总结 领域驱动设计的核心是领域模型，这一方法论可以通俗的理解为先找到业务中的领域模型，以领域模型为中心驱动项目的开发。而领域模型的设计精髓在于面向对象分析，在于对事物的抽象能力，一个领域驱动架构师必然是一个面向对象分析的大师。 在面向对象编程中讲究封装，讲究设计低耦合，高内聚的类。而对于一个软件工程来讲，仅仅只靠类的设计是不够的，我们需要把紧密联系在一起的业务设计为一个领域模型，让领域模型内部隐藏一些细节，这样一来领域模型和领域模型之间的关系就会变得简单。这一思想有效的降低了复杂的业务之间千丝万缕的耦合关系。 ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:9:0","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"用自己的话理解领域驱动模型 领域驱动模型是一种软件设计思想，软件开发之前，对产品所属领域进行业务知识梳理，梳理过程中，我们会形成相应领域知识，使用领域知识驱动软件设计，设计相应的领域模型。 我们需要把紧密联系在一起的业务设计为一个领域模型，让领域模型内部隐藏一些细节，这样一来领域模型和领域模型之间的关系就会变得简单，降低了复杂业务之间的耦合关系。 最后用代码实现领域模型。 ","date":"2020-07-23","objectID":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/:10:0","tags":["设计思想"],"title":"领域驱动模型DDD","uri":"/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8Bddd/"},{"categories":null,"content":"分布式架构网络通信 ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/:0:0","tags":["分布式"],"title":"分布式网络通信","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"categories":null,"content":"1.基本原理 要实现网络机器间的通讯，首先得来看看计算机系统网络通信的基本原理，在底层层面去看，网络通信需要做的就 是将流从一台计算机传输到另外一台计算机，基于传输协议和网络IO来实现，其中传输协议比较出名的有tcp、 udp等等，tcp、udp都是在基于Socket概念上为某类应用场景而扩展出的传输协议，网络IO，主要有bio、nio、 aio三种方式，所有的分布式应用通讯都基于这个原理而实现，只是为了应用的易用，各种语言通常都会提供一些 更为贴近应用易用的应用层协议。 ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/:1:0","tags":["分布式"],"title":"分布式网络通信","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"categories":null,"content":"2.什么是RPC RPC全称为remote procedure call，即远程过程调用。 借助RPC可以做到像本地调用一样调用远程服务，是一种进程间的通信方式 比如两台服务器A和B，A服务器上部署一个应用，B服务器上部署一个应用，A服务器上的应用想调用B服务器上的 应用提供的方法，由于两个应用不在一个内存空间，不能直接调用，所以需要通过网络来表达调用的语义和传达调 用的数据。 需要注意的是RPC并不是一个具体的技术，而是指整个网络远程调用过程。 ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/:2:0","tags":["分布式"],"title":"分布式网络通信","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"categories":null,"content":"RPC架构 一个完整的RPC架构里面包含了四个核心的组件，分别是Client，Client Stub，Server以及Server Stub，这个Stub 可以理解为存根。 客户端(Client)，服务的调用方。 客户端存根(Client Stub)，存放服务端的地址消息，再将客户端的请求参数打包成网络消息，然后通过网络远程发送给服务方。 服务端(Server)，真正的服务提供者。 服务端存根(Server Stub)，接收客户端发送过来的消息，将消息解包，并调用本地的方法。 ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/:2:1","tags":["分布式"],"title":"分布式网络通信","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"categories":null,"content":"RPC调用过程 (1) 客户端(client)以本地调用方式(即以接口的方式)调用服务; (2) 客户端存根(client stub)接收到调用后，负责将方法、参数等组装成能够进行网络传输的消息体(将消息体对象序列化为二进制); (3) 客户端通过sockets将消息发送到服务端; (4) 服务端存根( server stub)收到消息后进行解码(将消息对象反序列化); (5) 服务端存根( server stub)根据解码结果调用本地的服务; (6) 本地服务执行并将结果返回给服务端存根( server stub); (7) 服务端存根( server stub)将返回结果打包成消息(将结果消息对象序列化); (8) 服务端(server)通过sockets将消息发送到客户端; (9) 客户端存根(client stub)接收到结果消息，并进行解码(将结果消息发序列化); (10) 客户端(client)得到最终结果。 RPC的目标是要把2、3、4、7、8、9这些步骤都封装起来。 注意:无论是何种类型的数据，最终都需要转换成二进制流在网络上进行传输，数据的发送方需要将对象转换为二 进制流，而数据的接收方则需要把二进制流再恢复为对象。 在java中RPC框架比较多，常见的有Hessian、gRPC、Thrift、HSF (High Speed Service Framework)、Dubbo 等，其实对 于RPC框架而言，核心模块 就是通讯和序列化 ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/:2:2","tags":["分布式"],"title":"分布式网络通信","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"categories":null,"content":"3.RMI ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/:3:0","tags":["分布式"],"title":"分布式网络通信","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"categories":null,"content":"简介 Java RMI 指的是远程方法调用 (Remote Method Invocation),是java原生支持的远程调用 ,采用JRMP(Java Remote Messageing protocol)作为通信协议，可以认为是纯java版本的分布式远程调用解决方案， RMI主要用 于不同虚拟机之间的通信，这些虚拟机可以在不同的主机上、也可以在同一个主机上，这里的通信可以理解为一个 虚拟机上的对象调用另一个虚拟机上对象的方法。 1.客户端: 存根/桩(Stub):远程对象在客户端上的代理; 远程引用层(Remote Reference Layer):解析并执行远程引用协议; 传输层(Transport):发送调用、传递远程方法参数、接收远程方法执行结果。 2.服务端: 骨架(Skeleton):读取客户端传递的方法参数，调用服务器方的实际对象方法， 并接收方法执行后的返回值; 远程引用层(Remote Reference Layer):处理远程引用后向骨架发送远程方法调用; 传输层(Transport):监听客户端的入站连接，接收并转发调用到远程引用层。 3.注册表(Registry):以URL形式注册远程对象，并向客户端回复对远程对象的引用。 远程调用过程: 1)客户端从远程服务器的注册表中查询并获取远程对象引用。 2)桩对象与远程对象具有相同的接口和方法列表，当客户端调用远程对象时，实际上是由相应的桩对象代理完成的。 3 )远程引用层在将桩的本地引用转换为服务器上对象的远程引用后，再将调用传递给传输层(Transport)，由传输层通 过TCP协议发送调用; 4)在服务器端，传输层监听入站连接，它一旦接收到客户端远程调用后，就将这个引用转发给其上层的远程引用层; 5)服务器端的远程引用层将客户端发送的远程应用转换为本地虚拟机的引用后，再将请求传递给骨架(Skeleton); 6)骨架读取参数，又将请求传递给服务器，最后由服务器进行实际的方法调用。 结果返回过程: 1)如果远程方法调用后有返回值，则服务器将这些结果又沿着“骨架-\u003e远程引用层-\u003e传输层”向下传递; 2)客户端的传输层接收到返回值后，又沿着“传输层-\u003e远程引用层-\u003e桩”向上传递，然后由桩来反序列化这些返回值，并 将最终的结果传递给客户端程序。 ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/:3:1","tags":["分布式"],"title":"分布式网络通信","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"categories":null,"content":"开发流程 服务端: 1)定义Remote子接口，在其内部定义要发布的远程方法，并且这些方法都要Throws RemoteException; 2)定义实现远程接口，并且继承:UnicastRemoteObject 3)启动服务器:依次完成注册表的启动和远程对象绑定。 客户端: 1)通过符合JRMP规范的URL字符串在注册表中获取并强转成Remote子接口对象; 2)调用这个Remote子接口对象中的某个方法就是为一次远程方法调用行为。 ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/:3:2","tags":["分布式"],"title":"分布式网络通信","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"categories":null,"content":"代码实现 1.创建远程接口 import java.rmi.Remote; import java.rmi.RemoteException; /** * 远程服务对象接口必须继承Remote接口;同时方法必须抛出RemoteExceptino异常 */ public interface Hello extends Remote { public String sayHello(User user) throws RemoteException; } 其中有一个引用对象作为参数 import java.io.Serializable; /** * 引用对象应该是可序列化对象，这样才能在远程调用的时候:1. 序列化对象 2. 拷贝 3. 在网络中传输 * 4. 服务端反序列化 5. 获取参数进行方法调用; 这种方式其实是将远程对象引用传递的方式转化为值传递的方式 */ public class User implements Serializable { private String name; private int age; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age;} } 实现远程服务对象 import java.rmi.RemoteException; import java.rmi.server.UnicastRemoteObject; /** * 远程服务对象实现类写在服务端;必须继承UnicastRemoteObject或其子类 **/ public class HelloImpl extends UnicastRemoteObject implements Hello { /** * 因为UnicastRemoteObject的构造方法抛出了RemoteException异常，因此这里默认的构造方法必须写，必须 声明抛出RemoteException异常 * * @throws RemoteException */ private static final long serialVersionUID = 3638546195897885959L; protected HelloImpl() throws RemoteException { super(); // TODO Auto-generated constructor stub } @Override public String sayHello(User user) throws RemoteException { System.out.println(\"this is server, hello:\" + user.getName()); return \"success\"; } } 服务端程序 import java.net.MalformedURLException; import java.rmi.Naming; import java.rmi.RemoteException; import java.rmi.registry.LocateRegistry; /** * 服务端程序 **/ public class Server { public static void main(String[] args) { try { Hello hello = new HelloImpl(); // 创建一个远程对象，同时也会创建stub对象、skeleton对象 //本地主机上的远程对象注册表Registry的实例，并指定端口为8888，这一步必不可少(Java默认端口是1099)，必不可缺的一步，缺少注册表创建，则无法绑定对象到远程注册表上 //启动注册服务 LocateRegistry.createRegistry(8080); try { //绑定的URL标准格式为:rmi://host:port/name(其中协议名可以省略，下面两种写法都是正确的) Naming.bind(\"//127.0.0.1:8080/zm\", hello); //将stub引用绑定到服务地址上 } catch (MalformedURLException e) { // TODO Auto-generated catch block e.printStackTrace(); } System.out.println(\"service bind already!!\"); } catch (RemoteException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 客户端程序 import java.net.MalformedURLException; import java.rmi.Naming; import java.rmi.NotBoundException; import java.rmi.RemoteException; /** * 客户端程序 * @author zm * */ public class Client { public static void main(String[] args) { try { //在RMI服务注册表中查找名称为RHello的对象，并调用其上的方法 Hello hello = (Hello) Naming.lookup(\"//127.0.0.1:8080/zm\"); //获取远程对象 User user = new User(); user.setName(\"james\"); System.out.println(hello.sayHello(user)); } catch (MalformedURLException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (RemoteException e) { // TODO Auto-generated catch block e.printStackTrace(); } catch (NotBoundException e) { // TODO Auto-generated catch block e.printStackTrace(); } } } 启动服务端程序 客户端调用 ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/:3:3","tags":["分布式"],"title":"分布式网络通信","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"categories":null,"content":"4.BIO、NIO、AIO 同步和异步 ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/:4:0","tags":["分布式"],"title":"分布式网络通信","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"categories":null,"content":"同步和异步 同步(synchronize)、异步(asychronize)是指应用程序和内核的交互而言的. 同步: 指用户进程触发IO操作等待或者轮训的方式查看IO操作是否就绪。 同步举例: 银行取钱,我自己去取钱,取钱的过程中等待. 异步: 当一个异步进程调用发出之后，调用者不会立刻得到结果。而是在调用发出之后，被调用者通过状态、通知来通知 调用者，或者通过回调函数来处理这个调用。 使用异步IO时，Java将IO读写委托给OS处理，需要将数据缓冲区地址和大小传给OS，OS需要支持异步IO操作 举个例子: 异步举例: 我请朋友帮我取钱,他取到钱后返回给我. (委托给操作系统OS, OS需要支持IO异步API) ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/:4:1","tags":["分布式"],"title":"分布式网络通信","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"categories":null,"content":"阻塞和非阻塞 阻塞和非阻塞是针对于进程访问数据的时候,根据IO操作的就绪状态来采取不同的方式. 简单点说就是一种读写操作方法的实现方式. 阻塞方式下读取和写入将一直等待, 而非阻塞方式下,读取和写入方法 会理解返回一个状态值. 举个例子: 阻塞: ATM机排队取款，你只能等待排队取款(使用阻塞IO的时候，Java调用会一直阻塞到读写完成才返回。) 非阻塞: 柜台取款，取个号，然后坐在椅子上做其他事，等广播通知，没到你的号你就不能去，但你可以不断的问大堂经理 排到了没有。(使用非阻塞IO时，如果不能读写Java调用会马上返回，当IO事件分发器会通知可读写时再继续进行 读写，不断循环直到读写完成) 例子 老张煮开水。 老张，水壶两把(普通水壶，简称水壶;会响的水壶，简称响水壶)。 1 老张把水壶放到火上，站立着等水开。(同步阻塞) 2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。(同步非阻塞) 3 老张把响水壶放到火上，立等水开。(异步阻塞) 4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。(异步非阻塞) BIO 同步阻塞IO，B代表blocking 服务器实现模式为一个连接一个线程，即客户端有连接请求时服务器端就需要启动一个线程进行处理，如果这个连 接不做任何事情会造成不必要的线程开销，当然可以通过线程池机制改善。 适用场景:Java1.4之前唯一的选择，简单易用但资源开销太高 服务端 import java.io.IOException; import java.net.InetSocketAddress; import java.net.ServerSocket; import java.net.Socket; public class IOServer { public static void main(String[] args) throws Exception { //首先创建了一个serverSocket ServerSocket serverSocket = new ServerSocket(); serverSocket.bind(new InetSocketAddress(\"127.0.0.1\",8081)); while (true){ Socket socket = serverSocket.accept(); //同步阻塞 new Thread(()-\u003e{ try { byte[] bytes = new byte[1024]; int len = socket.getInputStream().read(bytes); //同步阻塞 System.out.println(new String(bytes,0,len)); socket.getOutputStream().write(bytes,0,len); socket.getOutputStream().flush(); } catch (IOException e) { e.printStackTrace(); } }).start(); } } } 客户端 import java.io.IOException; import java.net.Socket; public class IOClient { public static void main(String[] args) throws IOException { Socket socket = new Socket(\"127.0.0.1\",8081); socket.getOutputStream().write(\"hello\".getBytes()); socket.getOutputStream().flush(); System.out.println(\"server send back data =====\"); byte[] bytes = new byte[1024]; int len = socket.getInputStream().read(bytes); System.out.println(new String(bytes,0,len)); socket.close(); } } ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/:4:2","tags":["分布式"],"title":"分布式网络通信","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"categories":null,"content":"NIO NIO介绍 同步非阻塞IO (non-blocking IO / new io)是指JDK 1.4 及以上版本。 服务器实现模式为一个请求一个通道，即客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有IO请求时才启动一个线程进行处理。 通道(Channels) NIO 新引入的最重要的抽象是通道的概念。Channel 数据连接的通道。 数据可以从Channel读到Buffer中，也可以 从Buffer 写到Channel中 . 缓冲区(Buffers) 通道channel可以向缓冲区Buffer中写数据，也可以像buffer中存数据。 选择器(Selector) 使用选择器，借助单一线程，就可对数量庞大的活动 I/O 通道实时监控和维护。 特点 当一个连接创建后，不会需要对应一个线程，这个连接会被注册到多路复用器，所以一个连接只需要一个线程即可，所有的连接需要一个线程就可以操作，该线程的多路复用器会轮询，发现连接有请求时，才开启一个线程处 理。 BIO和NIO的区别 BIO是每个新连接都创建一个新线程，NIO新连接先进行注册，然后使用一个线程处理所有新连接； BIO读取是以字节形式，NIO是以字节快读取，效率更高。 ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/:4:3","tags":["分布式"],"title":"分布式网络通信","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"categories":null,"content":"AIO 异步非阻塞IO。A代表asynchronize 当有流可以读时,操作系统会将可以读的流传入read方法的缓冲区,并通知应用程序,对于写操作,OS将write方法的流 写入完毕是操作系统会主动通知应用程序。因此read和write都是异步 的，完成后会调用回调函数。 使用场景:连接数目多且连接比较长(重操作)的架构，比如相册服务器。重点调用了OS参与并发操作，编程比 较复杂。Java7开始支持 ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/:4:4","tags":["分布式"],"title":"分布式网络通信","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"categories":null,"content":"5.Netty Netty 是由 JBOSS 提供一个异步的、 基于事件驱动的网络编程框架。 Netty 可以帮助你快速、 简单的开发出一 个网络应用， 相当于简化和流程化了 NIO 的开发过程。 作为当前最流行 的 NIO 框架， Netty 在互联网领域、 大数据分布式计算领域、 游戏行业、 通信行业等获得了广泛的应用， 知名 的 Elasticsearch 、 Dubbo 框架内部都采用了 Netty。 为什么使用Netty NIO缺点 NIO 的类库和 API 繁杂，使用麻烦。你需要熟练掌握 Selector、ServerSocketChannel、SocketChannel、 ByteBuffer 等. 可靠性不强，开发工作量和难度都非常大 NIO 的 Bug。例如 Epoll Bug，它会导致 Selector 空轮询，最终导致 CPU 100%。 Netty优点 对各种传输协议提供统一的 API 高度可定制的线程模型——单线程、一个或多个线程池 更好的吞吐量，更低的等待延迟 更少的资源消耗 最小化不必要的内存拷贝 线程模型 Netty 抽象出两组线程池， BossGroup 专门负责接收客 户端连接， WorkerGroup 专门负责网络读写操作。 NioEventLoop 表示一个不断循环执行处理 任务的线程， 每个 NioEventLoop 都有一个 selector， 用于监听绑定 在其上的 socket 网络通道。 NioEventLoop 内部采用串行化设计， 从消息的读取-\u003e解码-\u003e处理-\u003e编码-\u003e发送， 始 终由 IO 线 程 NioEventLoop 负责。 Netty核心组件 ChannelHandler 及其实现类 ChannelHandler 接口定义了许多事件处理的方法， 我们可以通过重写这些方法去实现具 体的业务逻辑 我们经常需要自定义一个 Handler 类去继承 ChannelInboundHandlerAdapter， 然后通过 重写相应方法实现业 务逻辑， 我们接下来看看一般都需要重写哪些方法: public void channelActive(ChannelHandlerContext ctx)， 通道就绪事件 public void channelRead(ChannelHandlerContext ctx, Object msg)， 通道读取数据事件 public void channelReadComplete(ChannelHandlerContext ctx) ， 数据读取完毕事件 public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause)， 通道发生异常事件 ChannelPipeline ChannelPipeline 是一个 Handler 的集合， 它负责处理和拦截 inbound 或者 outbound 的事 件和操作， 相当于 一个贯穿 Netty 的链。 ChannelPipeline addFirst(ChannelHandler… handlers)， 把一个业务处理类(handler) 添加到链中的第一 个位置 ChannelPipeline addLast(ChannelHandler… handlers)， 把一个业务处理类(handler) 添加到链中的最后 一个位置 ChannelHandlerContext 这 是 事 件 处 理 器 上 下 文 对 象 ， Pipeline 链 中 的 实 际 处 理 节 点 。 每 个 处 理 节 点 ChannelHandlerContext 中 包 含 一 个 具 体 的 事 件 处 理 器 ChannelHandler ， 同 时 ChannelHandlerContext 中也绑定了对应的 pipeline 和 Channel 的信息，方便对 ChannelHandler 进行调用。 常用方法如下所示 ChannelFuture close()， 关闭通道 ChannelOutboundInvoker flush()， 刷新 ChannelFuture writeAndFlush(Object msg) ， 将 数 据 写 到 ChannelPipeline 中 当 前 ChannelHandler 的下一个 ChannelHandler 开始处理(出站) ChannelFuture 表示 Channel 中异步 I/O 操作的结果， 在 Netty 中所有的 I/O 操作都是异步的， I/O 的调 用会直接返回， 调用者 并不能立刻获得结果， 但是可以通过 ChannelFuture 来获取 I/O 操作 的处理状态。 常用方法如下所示: Channel channel()， 返回当前正在进行 IO 操作的通道 ChannelFuture sync()， 等待异步操作执行完毕 EventLoopGroup 和其实现类 NioEventLoopGroup EventLoopGroup 是一组 EventLoop 的抽象， Netty 为了更好的利用多核 CPU 资源， 一般 会有多个 EventLoop 同时工作， 每个 EventLoop 维护着一个 Selector 实例。 EventLoopGroup 提供 next 接口， 可以从组里面按照一 定规则获取其中一个 EventLoop 来处理任务。 在 Netty 服务器端编程中， 我们一般都需要提供两个 EventLoopGroup， 例如: BossEventLoopGroup 和 WorkerEventLoopGroup。 public NioEventLoopGroup()， 构造方法 public Future\u003c?\u003e shutdownGracefully()， 断开连接， 关闭线程 ServerBootstrap 和 Bootstrap ServerBootstrap 是 Netty 中的服务器端启动助手，通过它可以完成服务器端的各种配置; Bootstrap 是 Netty 中 的客户端启动助手， 通过它可以完成客户端的各种配置。 常用方法如下 所示: public ServerBootstrap group(EventLoopGroup parentGroup, EventLoopGroup childGroup)，该方法用于 服务器端， 用来设置两个 EventLoop public B group(EventLoopGroup group) ， 该方法用于客户端， 用来设置一个 EventLoop public B channel(Class\u003c? extends C\u003e channelClass)， 该方法用来设置一个服务器端的通道实现 public B option(ChannelOption option, T value)， 用来给 ServerChannel 添加配置 public ServerBootstrap childOption(ChannelOption childOption, T value)， 用来给接收到的 通道添加配置 public ServerBootstrap childHandler(ChannelHandler childHandler)， 该方法用来设置业务处理类(自定 义的 handler) public ChannelFuture bind(int inetPort) ， 该方法用于服务器端， 用来设置占用的端口号 public ChannelFuture connect(String inetHost, int inetPort) 该方法用于客户端， 用来连接服务器端 ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/:4:5","tags":["分布式"],"title":"分布式网络通信","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/"},{"categories":null,"content":"分布式 ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F/:0:0","tags":["分布式","分布式事务"],"title":"分布式理论","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"categories":null,"content":"1.分布式系统架构 ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F/:1:0","tags":["分布式","分布式事务"],"title":"分布式理论","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"categories":null,"content":"1.1概念 分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调 的系统。 俗的理解，所谓分布式系统，就是一个业务拆分成多个子业务，分布在不同的服务器节点，共同构成的系统称为分 布式系统，同一个分布式系统中的服务器节点在空间部署上是可以随意分布的，这些服务器可能放在不同的机柜 中，也可能在不同的机房中，甚至分布在不同的城市。 分布式与集群的区别: 集群:多个人在一起作同样的事 。 分布式 :多个人在一起作不同的事 。 分布式系统的特点: (1)分布性 (2)对等性 (3)并发性 (4)缺乏全局时钟 (5)故障总是会发生 ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F/:1:1","tags":["分布式","分布式事务"],"title":"分布式理论","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"categories":null,"content":"1.2.分布式系统面临的问题 1)通信异常 网络本身的不可靠性，因此每次网络通信都会伴随着网络不可用的风险(光纤、路由、DNS等硬件设备或系统的不 可用)，都会导致最终分布式系统无法顺利进行一次网络通信，另外，即使分布式系统各节点之间的网络通信能够 正常执行，其延时也会大于单机操作，存在巨大的延时差别，也会影响消息的收发过程，因此消息丢失和消息延迟 变的非常普遍。 2)网络分区 网络之间出现了网络不连通，但各个子网络的内部网络是正常的，从而导致整个系统的网络环境被切分成了若干个 孤立的区域，分布式系统就会出现局部小集群，在极端情况下，这些小集群会独立完成原本需要整个分布式系统才 能完成的功能，包括数据的事务处理，这就对分布式一致性提出非常大的挑战。 3)节点故障 节点故障是分布式系统下另一个比较常见的问题，指的是组成分布式系统的服务器节点出现的宕机或\"僵死\"现象， 根据经验来说，每个节点都有可能出现故障，并且经常发生. 4)三态 分布式系统每一次请求与响应存在特有的“三态”概念，即成功、失败和超时。 分布式系统中，由于网络是不可靠的，虽然绝大部分情况下，网络通信能够接收到成功或失败的响应，但当网络出 现异常的情况下，就会出现超时现象，通常有以下两种情况: 由于网络原因，该请求并没有被成功的发送到接收方，而是在发送过程就发生了丢失现象。 该请求成功的被接收方接收后，并进行了处理，但在响应反馈给发送方过程中，发生了消息丢失现象。 ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F/:1:2","tags":["分布式","分布式事务"],"title":"分布式理论","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"categories":null,"content":"1.3.分布式理论:一致性 1)什么是分布式一致性 分布式数据一致性，指的是数据在多份副本中存储时，各副本中的数据是一致的。 2)副本一致性 分布式系统当中，数据往往会有多个副本。如果是一台数据库处理所有的数据请求，那么通过ACID四原则，基本 可以保证数据的一致性。而多个副本就需要保证数据会有多份拷贝。这就带来了同步的问题，因为我们几乎没有办 法保证可以同时更新所有机器当中的包括备份所有数据。 网络延迟，即使我在同一时间给所有机器发送了更新数据 的请求，也不能保证这些请求被响应的时间保持一致存在时间差，就会存在某些机器之间的数据不一致的情况。 3)一致性分类 强一致性 这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往 对系统的性能影响大。但是强一致性很难实现。 弱一致性 这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不承诺多久之后数据能够达到一致， 但会尽可能地保证到某个时间级别(比如秒级别)后，数据能够达到一致状态。 最终一致性 最终一致性是所有分布式一致性模型当中最弱的。可以认为是没有任何优化的“最”弱一致性，它的意思是说，我不考虑 所有的中间状态的影响，只保证当没有新的更新之后，经过一段时间之后，最终系统内所有副本的数据是正确的。 它最大程度上保证了系统的并发能力，也因此，在高并发的场景下，它也是使用最广的一致性模型。 ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F/:1:3","tags":["分布式","分布式事务"],"title":"分布式理论","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"categories":null,"content":"1.4.分布式理论:CAP定理 CAP定理 CAP 理论含义是，一个分布式系统不可能同时满足一致性(C:Consistency)，可用性(A: Availability)和分区容错 性(P:Partition tolerance)这三个基本需求，最多只能同时满足其中的2个。 C - Consistency 一致性 分布式系统当中的一致性指的是所有节点的数据一致，或者说是所有副本的数据一致 一致性是值写操作后读操作可以读到最新的数据状态,当数据分布在多个节点上时,从任意节点读取到的数据都是最新的. 商品信息读写要满足一致性需要实现如下目标: 1.商品服务写入主数据库成功, 则想从数据库查询数据也成功 2.商品服务写入主数据库失败,则向从数据库查询也失败 如何实现一 致性? 1.写入主数据库后要数据同步到从数据库 2.写入主数据库后,在向从数据库同步期间要将从数据库锁定, 等待同步完成后在释放锁,以免在写新数据后,向从数据 库查询到旧的数据. 分布式一致性的特点: 1.由于存在数据库同步过程,写操作的响应会有一定的延迟 2.为了保定数据的一致性,对资源暂时锁定,待数据同步完成后释放锁定资源 3.如果请求数据同步失败的节点则会返回错误信息, 一定不会返回旧数据. A - Availability 可用性 Reads and writes always succeed. 也就是说系统一直可用，而且服务一直保持正常 可用性是指任何操作都可以得到响应的结果,且不会出现响应超时或响应错误。 商品信息读写要满足可用性需要实现如下目标: 1.从数据库接收到数据库查询的请求则立即能够响应数据查询结果 2.从数据库不允许出现响应超时或错误 如何实现可用性? 1.写入主数据库后要将数据同步到从数据 2.由于要保证数据库的可用性,不可以将数据库中资源锁定 3.即使数据还没有同步过来,从数据库也要返回查询数据, 哪怕是旧数据,但不能返回错误和超时. P - Partition tolerance 分区容错性 系统在遇到一些节点或者网络分区故障的时候，仍然能够提供满足一致性和可用性的服务 分布式系统的各个节点部署在不同的子网中, 不可避免的会出现由于网络问题导致节点之间通信失败,此时仍可以对外提供服务, 这个就是分区容错性 (分区容忍性). 商品信息读写要满足分区容错性需要实现如下目标: 1.主数据库想从数据库同步数据失败不形象写操作 2.其中一个节点挂掉不会影响另一个节点对外提供服务 如何实现分区容错性? 1.尽量使用异步取代同步操作,举例 使用异步方式将数据从主数据库同步到从数据库, 这样节点之间能有效的实现松 耦合; 2.添加数据库节点,其中一个从节点挂掉,由其他从节点提供服务 CAP只能 3 选 2 有用户向N1发送了请求更改了数据，将数据库从V0更新成了V1。由于网络断开，所以N2数据库依然是V0，如果这个时候 有一个请求发给了N2，但是N2并没有办法可以直接给出最新的结果V1，这个时候该怎么办呢? 这个时候无法两种方法，一种是将错就错，将错误的V0数据返回给用户。第二种是阻塞等待，等待网络通信恢复，N2中 的数据更新之后再返回给用户。显然前者牺牲了一致性，后者牺牲了可用性。 这个例子虽然简单，但是说明的内容却很重要。在分布式系统当中，CAP三个特性我们是无法同时满足的，必然要舍弃一 个。三者舍弃一个，显然排列组合一共有三种可能。 舍弃A(可用性)，保留CP(一致性和分区容错性) 一个系统保证了一致性和分区容错性，舍弃可用性。也就是说在极端情况下，允许出现系统无法访问的情况出现，这个 时候往往会牺牲用户体验，让用户保持等待，一直到系统数据一致了之后，再恢复服务。 舍弃C(一致性)，保留AP(可用性和分区容错性) 这种是大部分的分布式系统的设计，保证高可用和分区容错，但是会牺牲一致性。 舍弃P(分区容错性)，保留CA(一致性和可用性) 如果要舍弃P，那么就是要舍弃分布式系统，CAP也就无从谈起了。可以说P是分布式系统的前提，所以这种情况是不存在 的。 能否同时满足3个？ 网络分区存在，需要保证C一致性，通信失败，无法保证一致性，若需要保证一致性，需要停止服务，解决网络分区问题，此时无法保证A可用性。 P是分布式系统前提，不能保证P，则使用单节点系统。 ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F/:1:4","tags":["分布式","分布式事务"],"title":"分布式理论","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"categories":null,"content":"1.5.分布式理论:BASE 理论 BASE 全称:Basically Available(基本可用)，Soft state(软状态),和 Eventually consistent(最终一致性)三个 短语的缩写，来自 ebay 的架构师提出。 BASE是对CAP中一致性和可用性权衡的结果。 BASE理论的核心思想是:即使无法做到强一致性，但每个应用都可 以根据自身业务特点，采用适当的方式来使系统达到最终一致性。 Basically Available(基本可用) 基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性——但请注意，这绝不等价于系统不可用。 响应时间上的损失: 正常情况下，一个在线搜索引擎需要在0.5秒之内返回给用户相应的查询结果，但由于出 现故障(比如系统部分机房发生断电或断网故障)，查询结果的响应时间增加到了1~2秒。 一个系统保证了一致性和分区容错性，舍弃可用性。也就是说在极端情况下，允许出现系统无法访问的情况出现，这个 时候往往会牺牲用户体验，让用户保持等待，一直到系统数据一致了之后，再恢复服务。 如果要舍弃P，那么就是要舍弃分布式系统，CAP也就无从谈起了。可以说P是分布式系统的前提，所以这种情况是不存在 的。 功能上的损失: 正常情况下，在一个电子商务网站(比如淘宝)上购物，消费者几乎能够顺利地完成每一笔 订单。但在一些节日大促购物高峰的时候(比如双十一、双十二)，由于消费者的购物行为激增，为了保护 系统的稳定性(或者保证一致性)，部分消费者可能会被引导到一个降级页面。 Soft state(软状态) 什么是软状态呢?相对于一致性，要求多个节点的数据副本都是一致的，这是一种 “硬状态”。 软状态指的是:允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同 节点的数据副本之间进行数据同步的过程中存在延迟。 Eventually consistent(最终一致性) 最终一致性强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。 因此最终一致性的本质是需要系统保证最终数据能够达到一致，而不需要实时保证系统数据的强一致性。 因果一致性 如果节点A更新完成某个数据通知了节点B，那么节点B之后对该数据的访问和修改都基于A更新后的值。与此同时，和节点A无因果关系的就节点C的数据访问则没有这样的限制。 读已之所写 节点A更新一个数据后，它自身总是能够访问到自身更新过的最新值，而不会看到旧值，也就是说，对于单个数据获取者来说，其读取到的数据，一定不会比上次写入的值旧。因此，读已之所写也可以看成是一种特殊的因果一致性。 会话一致性 会话一致性将对系统数据的访问过程框定在了一个会话当中；系统能保证在同一个有效的会话中实现“读已之所写”的一致性，也就是说，执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。 单调读一致性 单调读一致性是指如果一个节点从系统中读取一个数据项某个值之后，那么系统对于该节点后续的任何数据访问都不应该返回更旧的值。 单调写一致性 指一个系统要能够保证来自同一个节点的写操作被顺序执行。 BASE理论面向大型高可用可扩展的分布式系统，和传统食物的ACID是相反的，它完全不同于ACID的强一致模型，而是通过牺牲强一致性来获得可用性，并允许数据在同一时间段是不一致的，但最终要保证数据一致。 ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F/:1:5","tags":["分布式","分布式事务"],"title":"分布式理论","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"categories":null,"content":"1.6一致性协议 2PC 什么是2PC 2PC ( Two-Phase Commit缩写)即两阶段提交协议，是将整个事务流程分为两个阶段，准备阶段(Prepare phase)、提交阶段(commit phase)，2是指两个阶段，P是指准备阶段，C是指提交阶段。 数据库两阶段提交如下： 两个阶段过程: 准备阶段(Prepare phase):事务管理器给每个参与者发送Prepare消息，每个数据库参与者在本地执行事 务，并写本地的Undo/Redo日志，此时事务没有提交。 (Undo日志是记录修改前的数据，用于数据库回 滚，Redo日志是记录修改后的数据，用于提交事务后写入数 据文件) 提交阶段(commit phase):如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者 发送回滚(Rollback)消息;否则，发送提交(Commit)消息;参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。注意:必须在最后阶段释放锁资源。 2PC执行流程 事务提交流程 成功执行事务 阶段一: 事务询问 协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。 执行事务 (写本地的Undo/Redo日志) 各参与者向协调者反馈事务询问的响应 总结: 各个参与者进行投票是否让事务进行. 阶段二: 发送提交请求: 协调者向所有参与者发出 commit 请求。 事务提交: 参与者收到 commit 请求后，会正式执行事务提交操作，并在完成提交之后释放整个事务执行期间占用的事务资 源。 反馈事务提交结果: 参与者在完成事务提交之后，向协调者发送 Ack 信息。 完成事务: 协调者接收到所有参与者反馈的 Ack 信息后，完成事务。 中断事务步骤如下: 假如任何一个参与者向协调者反馈了No响应，或者在等待超时之后，协调者尚无法接收到所有参与者的反馈响 应，那么就会中断事务 阶段一: 事务询问 协调者向所有的参与者发送事务内容，询问是否可以执行事务提交操作，并开始等待各参与者的响应。 执行事务 (写本地的Undo/Redo日志) 各参与者向协调者反馈事务询问的响应 总结: 各个参与者进行投票是否让事务进行 阶段二 发送回滚请求: 协调者向所有参与者发出 Rollback 请求。 事务回滚: 参与者接收到 Rollback 请求后，会利用其在阶段一中记录的 Undo 信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源。 反馈事务回滚结果: 参与者在完成事务回滚之后，向协调者发送 Ack 信息。 中断事务: 协调者接收到所有参与者反馈的 Ack 信息后，完成事务中断。 从上面的逻辑可以看出，二阶段提交就做了2个事情:投票，执行。 PC 优点缺点 优点 原理简单，实现方便 缺点 同步阻塞，单点问题，数据不一致，过于保守 同步阻塞: 二阶段提交协议存在最明显也是最大的一个问题就是同步阻塞，在二阶段提交的执行过程中，所有参与该事务操作 的逻辑都处于阻塞状态，也就是说，各个参与者在等待其他参与者响应的过程中，无法进行其他操作。这种同步阻 塞极大的限制了分布式系统的性能。 单点问题: 协调者在整个二阶段提交过程中很重要，如果协调者在提交阶段出现问题，那么整个流程将无法运转，更重要的 是:其他参与者将会处于一直锁定事务资源的状态中，而无法继续完成事务操作。 数据不一致: 假设当协调者向所有的参与者发送 commit 请求之后，发生了局部网络异常或者是协调者在尚未发送完所有 commit 请求之前自身发生了崩溃，导致最终只有部分参与者收到了 commit 请求。这将导致严重的数据不一致问 题。 过于保守: 如果在二阶段提交的提交询问阶段中，参与者出现故障而导致协调者始终无法获取到所有参与者的响应信息的话， 这时协调者只能依靠其自身的超时机制来判断是否需要中断事务，显然，这种策略过于保守。换句话说，二阶段提 交协议没有设计较为完善的容错机制，任意一个节点失败都会导致整个事务的失败。 ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F/:1:6","tags":["分布式","分布式事务"],"title":"分布式理论","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"categories":null,"content":"1.7一致性协议 3PC 什么是三阶段提交 3PC，全称 “three phase commit”，是 2PC 的改进版，将 2PC 的 “提交事务请求” 过程一分为二，共形成了由 CanCommit、PreCommit和doCommit三个阶段组成的事务处理协议。 阶段一:CanCommit 事务询问 协调者向所有的参与者发送一个包含事务内容的canCommit请求，询问是否可以执行事务提交操作，并开始等待 各参与者的响应。 各参与者向协调者反馈事务询问的响应 参与者在接收到来自协调者的包含了事务内容的canCommit请求后，正常情况下，如果自身认为可以顺利执行事 务，则反馈Yes响应，并进入预备状态，否则反馈No响应。 阶段二:PreCommit 协调者在得到所有参与者的响应之后，会根据结果有2种执行操作的情况:执行事务预提交，或者中断事务 假如所有参与反馈的都是Yes，那么就会执行事务预提交。 执行事务预提交分为 3 个步骤 发送预提交请求: 协调者向所有参与者节点发出preCommit请求，并进入prepared阶段。 事务预提交: 参与者接收到preCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中。 各参与者向协调者反馈事务执行的结果: 若参与者成功执行了事务操作，那么反馈Ack 若任一参与者反馈了No响应，或者在等待超时后，协调者尚无法接收到所有参与者反馈，则中断事务 中断事务也分为2个步骤: 发送中断请求: 协调者向所有参与者发出abort请求。 中断事务: 无论是收到来自协调者的abort请求或者等待协调者请求过程中超时，参与者都会中断事务 阶段三:do Commit 该阶段做真正的事务提交或者完成事务回滚，所以就会出现两种情况: 执行事务提交 发送提交请求: 进入这一阶段，假设协调者处于正常工作状态，并且它接收到了来自所有参与者的Ack响应，那么他将从预提交状态转化为提交状态，并向所有的参与者发送doCommit请求。 事务提交: 参与者接收到doCommit请求后，会正式执行事务提交操作，并在完成提交之后释放整个事务执行过程中占用的事 务资源。 反馈事务提交结果: 参与者在完成事务提交后，向协调者发送Ack响应。 完成事务: 协调者接收到所有参与者反馈的Ack消息后，完成事务。 中断事务 发送中断请求: 协调者向所有的参与者节点发送abort请求。 事务回滚: 参与者收到abort请求后，会根据记录的Undo信息来执行事务回滚，并在完成回滚之后释放整 个事务执行期间占用的资源。 反馈事务回滚结果: 参与者在完成事务回滚后，向协调者发送Ack消息。 中断事务: 协调者接收到所有参与者反馈的Ack消息后，中断事务。 注意: 一旦进入阶段三，可能会出现 2 种故障: 协调者出现问题 协调者和参与者之间的网络故障 如果出现了任一一种情况，最终都会导致参与者无法收到 doCommit 请求或者 abort 请求，针对这种情况，参与者都会在等待超时之后，继续进行事务提交. 2PC对比3PC 1.首先对于协调者和参与者都设置了超时机制(在2PC中，只有协调者拥有超时机制，即如果在一定时间内没有收 到参与者的消息则默认失败),主要是避免了参与者在长时间无法与协调者节点通讯(协调者挂掉了)的情况下，无 法释放资源的问题，因为参与者自身拥有超时机制会在超时后，自动进行本地commit从而进行释放资源。而这种 机制也侧面降低了整个事务的阻塞时间和范围。 2.通过CanCommit、PreCommit、DoCommit三个阶段的设 计，相较于2PC而言，多设置了一个缓冲阶段保证了在最后提交阶段之前各参与节点的状态是一致的 。 3.PreCommit是一个缓冲，保证了在最后提交阶段之前各参与节点的状态是一致的。 问题:3PC协议并没有完全解决数据不一致问题。 ","date":"2020-07-22","objectID":"/%E5%88%86%E5%B8%83%E5%BC%8F/:1:7","tags":["分布式","分布式事务"],"title":"分布式理论","uri":"/%E5%88%86%E5%B8%83%E5%BC%8F/"},{"categories":null,"content":"Spring ","date":"2020-07-17","objectID":"/spring/:0:0","tags":["Spring"],"title":"Spring详解","uri":"/spring/"},{"categories":null,"content":"概述 ","date":"2020-07-17","objectID":"/spring/:1:0","tags":["Spring"],"title":"Spring详解","uri":"/spring/"},{"categories":null,"content":"简介 Spring 是分层的 full-stack(全栈) 轻量级开源框架，以 IoC 和 AOP 为内核，提供了展现层 Spring MVC 和业务层事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，已 经成为使用最多的 Java EE 企业应用开源框架。 ","date":"2020-07-17","objectID":"/spring/:1:1","tags":["Spring"],"title":"Spring详解","uri":"/spring/"},{"categories":null,"content":"优势 方便解耦，简化开发 通过Spring提供的IoC容器，可以将对象间的依赖关系交由Spring进行控制，避免硬编码所造成的 过度程序耦合。用户也不必再为单例模式类、属性文件解析等这些很底层的需求编写代码，可以更 专注于上层的应用。 AOP编程的支持 通过Spring的AOP功能，方便进行面向切面的编程，许多不容易用传统OOP实现的功能可以通过AOP轻松应付。 声明式事务的支持 @Transactional 可以将我们从单调烦闷的事务管理代码中解脱出来，通过声明式方式灵活的进行事务的管理，提高 开发效率和质量。 方便程序的测试 可以用非容器依赖的编程方式进行几乎所有的测试工作，测试不再是昂贵的操作，而是随手可做的 事情。 方便集成各种优秀框架 Spring可以降低各种框架的使用难度，提供了对各种优秀框架(Struts、Hibernate、Hessian、 Quartz等)的直接支持。 降低JavaEE API的使用难度 Spring对JavaEE API(如JDBC、JavaMail、远程调用等)进行了薄薄的封装层，使这些API的使用难度大为降低。 源码是经典的 Java 学习范例 Spring的源代码设计精妙、结构清晰、匠心独用，处处体现着大师对Java设计模式灵活运用以及对Java技术的高深造诣。它的源代码无意是Java技术的最佳实践的范例。 ","date":"2020-07-17","objectID":"/spring/:1:2","tags":["Spring"],"title":"Spring详解","uri":"/spring/"},{"categories":null,"content":"核心结构 Spring核心容器(Core Container) 容器 Spring框架最核心的部分，它管理着Spring应用中 bean的创建、配置和管理。在该模块中，包括了Spring bean工厂，它为Spring提供了DI的功能。 基于bean工厂，我们还会发现有多种Spring应用上下文的实现。所有的Spring模块都构建于核心 容器之上。 面向切面编程(AOP)/Aspects Spring对面向切面编程提供了丰富的支持。这个模块是Spring应 用系统中开发切面的基础，与DI一样，AOP可以帮助应用对象解耦。 数据访问与集成(Data Access/Integration) Spring的JDBC和DAO模块封装了大量样板代码，这样可以使得数据库代码变得简洁，也可以更专 注于我们的业务，还可以避免数据库资源释放失败而引起的问题。 另外，Spring AOP为数据访问 提供了事务管理服务，同时Spring还对ORM进行了集成，如Hibernate、MyBatis等。该模块由 JDBC、Transactions、ORM、OXM 和 JMS 等模块组成。 Web 模块 该模块提供了SpringMVC框架给Web应用，还提供了多种构建和其它应用交互的远程调用方 案。 SpringMVC框架在Web层提升了应用的松耦合水平。 Test 为了使得开发者能够很方便的进行测试，Spring提供了测试模块以致力于Spring应用的测 试。 通过该模块，Spring为使用Servlet、JNDI等编写单元测试提供了一系列的mock对象实现。 ","date":"2020-07-17","objectID":"/spring/:1:3","tags":["Spring"],"title":"Spring详解","uri":"/spring/"},{"categories":null,"content":"版本 5.x JDK8+ 4.x JDK6+ 3.x JDK5+ 目前稳定版本5.1.12 ","date":"2020-07-17","objectID":"/spring/:1:4","tags":["Spring"],"title":"Spring详解","uri":"/spring/"},{"categories":null,"content":"核心思想 ","date":"2020-07-17","objectID":"/spring/:2:0","tags":["Spring"],"title":"Spring详解","uri":"/spring/"},{"categories":null,"content":"IOC 定义 IoC Inversion of Control (控制反转/反转控制)，注意它是一个技术思想，不是一个技术实现 控制反转 控制:指的是对象创建(实例化、管理)的权利 反转:控制权交给外部环境了(spring框架、IoC容器) 解决什么问题 IoC解决对象之间的耦合问题 IOC与DI区别 DI:Dependancy Injection(依赖注入) IOC和DI描述的同一件事情（对象实例化及依赖关系维护），只是角度不同 IOC站在对象的角度，对象实例化机器管理的权利交给了（反转）给了容器 DI是站在容器角度，容器会把对象依赖的其他对象注入（送进去），比如A对象实例化过程中因为声明了一个B类型的属性，name就需要容器把B对象注入给A ","date":"2020-07-17","objectID":"/spring/:2:1","tags":["Spring"],"title":"Spring详解","uri":"/spring/"},{"categories":null,"content":"AOP 定义 AOP: Aspect oriented Programming 面向切面编程/面向方面编程 AOP是OOP的延续 OOP 封装、继承和多态 oop是一种垂直继承体系 无法解决顶级父类代码重复 解决什么问题 在不改变原有业务逻辑情况下，增强横切逻辑代码，根本上解耦合，避免横切逻辑代码重复 切/面理解 「切」:指的是横切逻辑，原有业务逻辑代码我们不能动，只能操作横切逻辑代码，所以面向横切逻辑 「面」:横切逻辑代码往往要影响的是很多个方法，每一个方法都如同一个点，多个点构成面，有一个 面的概念在里面 ","date":"2020-07-17","objectID":"/spring/:2:2","tags":["Spring"],"title":"Spring详解","uri":"/spring/"},{"categories":null,"content":"应用 ","date":"2020-07-17","objectID":"/spring/:3:0","tags":["Spring"],"title":"Spring详解","uri":"/spring/"},{"categories":null,"content":"IOC 基础 beans.xml 定义需要实例化对象的类的全限定雷鸣以及类之间依赖关系的描述 BeanFactory IOC容器，通过反射技术实例化对象并维护对象之间的依赖关系 Spring框架的IOC实现 纯xml（bean信息定义全部配置在xml中） xml+注解 部分bean使用xml定义，部分bean使用注解定义 纯注解模式 所有bean都是注解来定义 JavaSE应用 ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class) JavaWeb应用 ContextLoaderListener（监听器去加载注解配置类） BeanFactory、ApplicationContext BeanFactory是Spring框架中IoC容器的顶层接口,它只是用来定义一些基础功能,定义一些基础规范,而 ApplicationContext是它的一个子接口，所以ApplicationContext是具备BeanFactory提供的全部功能 的。 通常，我们称BeanFactory为SpringIOC的基础容器，ApplicationContext是容器的高级接口，比 BeanFactory要拥有更多的功能，比如说国际化支持和资源访问(xml，java配置类)等等 IOC实现方法详解 纯xml 实例化Bean的三种方式 使用无参构造函数 它会通过反射调用无参构造函数来创建对象。如果类中没有无参构造函数，将创建 失败。 静态方法创建 实例化方法创建 Bean标签属性 id 用于给bean提供一个唯一标识。在一个标签内部，标识必须唯一。 class 用于指定创建Bean对象的全限定类名。 name 用于给bean提供一个或多个名称。多个名称用空格分隔。 factory-bean 用于指定创建当前bean对象的工厂bean的唯一标识。当指定了此属性之后， class属性失效。 factory-method 用于指定创建当前bean对象的工厂方法，如配合factory-bean属性使用， 则class属性失效。如配合class属性使用，则方法必须是static的。 scope 用于指定bean对象的作用范围。通常情况下就是singleton。当要用到多例模式时， 可以配置为prototype。 init-method 用于指定bean对象的初始化方法，此方法会在bean对象装配后调用。必须是 一个无参方法。 destory-method 用于指定bean对象的销毁方法，此方法会在bean对象销毁前执行。它只 能为scope是singleton时起作用。 DI 构造函数注入 顾名思义，就是利用带参构造函数实现对类成员的数据赋值 constructor-arg name:用于给构造函数中指定名称的参数赋值。 index:用于给构造函数中指定索引位置的参数赋值。 value:用于指定基本类型或者String类型的数据。 ref:用于指定其他Bean类型的数据。写的是其他bean的唯一标识。 set方法注入 它是通过类成员的set方法实现数据的注入。(使用最多的) property name:指定注入时调用的set方法名称。(注:不包含set这三个字母,druid连接池指定属性名称) value:指定注入的数据。它支持基本类型和String类型。 ref:指定注入的数据。它支持其他bean类型。写的是其他bean的唯一标识。 \u003cproperty name\"name\" value=“zhangsan”/\u003e xml和注解 bean声明 @Component(“accountDao”)，注解加在类上 bean的id属性内容直接配置在注解后面如果不配置，默认定义个这个bean的id为类 的类名首字母小写; 另外，针对分层代码开发提供了@Componenet的三种别名@Controller、 @Service、@Repository分别用于控制层类、服务层类、dao层类的bean定义，这 四个注解的用法完全一样，只是为了更清晰的区分而已 标签scope @Scope(“prototype”)，默认单例，注解加在类上 init- method @PostConstruct，注解加在方法上，该方法就是初始化后调用的方法 destory- method @PreDestory，注解加在方法上，该方法就是销毁前调用的方法 DI @Autowired 按照类型注入。 @Qualifier 当一个类型有多个bean值的时候，Qualifier告诉Spring具体去装配哪个对象 org.springframework.beans.factory.annotation.Autowired @Resource javax.annotation.Resourc ByName 默认 ByType 设定 name、type 找到唯一匹配bean，找不到抛异常 name 名称匹配，找不到抛异常 type 类型匹配唯一bean,找不到或多个抛异常 纯注解 @Configuration 注解，表名当前类是一个配置类 @ComponentScan 注解，替代 context:component-scan @PropertySource 引入外部属性配置文件 @Import 引入其他配置类 @Value 对变量赋值，可以直接赋值，也可以使用 ${} 读取资源配置文件中的信息 @Bean 将方法返回对象加入 SpringIOC 容器 高级 lazy-Init 延迟加载 ApplicationContext 容器的默认行为是在启动服务器时将所有 singleton bean 提前进行实例化。提前 实例化意味着作为初始化过程的一部分，ApplicationContext 实例会创建并配置所有的singleton bean。 设置 lazy-init 为 true 的 bean 将不会在 ApplicationContext 启动时提前被实例化，而是第一次向容器 通过 getBean 索取 bean 时实例化的。 scope=“pototype” lazy-init=“false”，容器启动时也不 会实例化bean，而是调用 getBean 方法实例化的。 应用 (1)开启延迟加载一定程度提高容器启动和运转性能 (2)对于不常使用的 Bean 设置延迟加载，这样偶尔使用的时候再加载，不必要从一开始该 Bean 就占 用资源 BeanFactory 容器的顶级接口，定义了容器的一些基础行为，负责生产和管理Bean的一个工厂， 具体使用它下面的子接口类型，比如ApplicationContext FactoryBean actoryBean可以生成某一个类型的Bean实例(返回给我们)，也就是说我们可以借助于它自定义Bean的创建过程。 // 可以让我们自定义Bean的创建过程(完成复杂Bean的定义) public interface FactoryBean { @Nullable // 返回FactoryBean创建的Bean实例，如果isSingleton返回true，则该实例会放到Spring容器 的单例对象缓存池中Map T getObject() throws Exception; @Nullable // 返回FactoryBean创建的Bean类型 Class\u003c?\u003e getObjectType(); // 返回作用域是否单例 default boolean isSingleton() { return true; } } 后置处理器 BeanPostProcessor BeanFactoryPostProcessor Spring Bean的生命周期 1)根据配置情况调用 Bean 构造方法或工厂方法实例化 Bean。 2)利用依赖注入完成 Bean 中所有属性值的配置注入。 3)如果 Bean 实现了 BeanNameAware 接口，则 Spring 调用 Bean 的 setBeanName() 方法传入当前 Bean 的 id 值。 4)如果 Bean 实现了 BeanFactoryAware 接口，则 Spring 调用 setBeanFactory() 方法传入当前工厂实例的引用。 5)如果 Bean 实现了 ApplicationContextAware 接口，则 Spring 调用 setApplicationContext() 方法传入当前 ApplicationContext 实例的引用。 6)如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的预初始化方法postProcessBeforeInitialzation() 对 Bean 进行加工操作，此处非常重要，Spring 的 AOP 就是利用它实现的。 7)如果 Bean 实现了 InitializingBean 接口，则 Spring 将调用 afterPropertiesSet() 方法。 8)如果在配置文件中通过 init-method 属性指定了初始化方法，则调用该初始化方法。 9)如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调用该接口的初始化方法 postProcessAfterInitialization()。此时，Bean 已经可以被应用系统使用了。 10)如果在 中指定了该 Bean 的作用范围为 scope=“singleto","date":"2020-07-17","objectID":"/spring/:3:1","tags":["Spring"],"title":"Spring详解","uri":"/spring/"},{"categories":null,"content":"AOP ","date":"2020-07-17","objectID":"/spring/:3:2","tags":["Spring"],"title":"Spring详解","uri":"/spring/"},{"categories":null,"content":"源码 ","date":"2020-07-17","objectID":"/spring/:4:0","tags":["Spring"],"title":"Spring详解","uri":"/spring/"},{"categories":null,"content":"IOC 源码编译 core-oxm-context-beans-aspects-aop Task-》other-》compileTestJava IOC容器初始化 BeanFactory 顶层容器(根容器)，不能被实例化，定义容器基本功能 创建流程 构造器执行、初始化方法执行、Bean后置处理器的before/after方法 AbstractApplicationContext#refresh#finishBeanFactoryInitialization Bean工厂后置处理器初始化、方法执行 AbstractApplicationContext#refresh#invokeBeanFactoryPostProcessors Bean后置处理器初始化 AbstractApplicationContext#refresh#registerBeanPostProcessors AbstractApplicationContext#refresh prepareRefresh 环境准备 obtainFreshBeanFactory 获取BeanFactory：默认实现是DefaultListableBeanFactory 是否存在，已存在，销毁 refreshBeanFactory new DefaultListableBeanFactory loadBeanDefinitions getBeanFactory 加载BeanDefition并注册到BeanDefitionRegistry prepareBeanFactory BeanFactory前置处理器 postProcessBeanFactory BeanFacotry后置处理器 invokeBeanFactoryPostProcessors 实例化postProcessBeanFactory，并调用接口方法 registerBeanPostProcessors 注册BeanPostProcessor bean的后置处理器，创建bean的前后执行 finishBeanFactoryInitialization 初始化所有剩下的非懒加载的单例bean 初始化创建非懒加载方式的单例Bean实例 填充属性 初始化方法调用 调用BeanPostProcessor后置处理器对实例bean进行后置处理 ","date":"2020-07-17","objectID":"/spring/:4:1","tags":["Spring"],"title":"Spring详解","uri":"/spring/"},{"categories":null,"content":"AOP XMind: ZEN - Trial Version ","date":"2020-07-17","objectID":"/spring/:4:2","tags":["Spring"],"title":"Spring详解","uri":"/spring/"},{"categories":null,"content":"Tomcat详解 ","date":"2020-07-14","objectID":"/tomcat/:0:0","tags":["Tomcat"],"title":"Tomcat详解","uri":"/tomcat/"},{"categories":null,"content":"目录结构 ","date":"2020-07-14","objectID":"/tomcat/:1:0","tags":["Tomcat"],"title":"Tomcat详解","uri":"/tomcat/"},{"categories":null,"content":"bin：tomocat启动文件 ","date":"2020-07-14","objectID":"/tomcat/:1:1","tags":["Tomcat"],"title":"Tomcat详解","uri":"/tomcat/"},{"categories":null,"content":"conf 1.logging.properties 日志配置； 2.server.xml服务器端口等配置； 3.tomcat-users.xml tomcat用户角色、权限配置； 4.web.xml应用全局默认配置，若服务中进行了配置，则会覆盖 ","date":"2020-07-14","objectID":"/tomcat/:1:2","tags":["Tomcat"],"title":"Tomcat详解","uri":"/tomcat/"},{"categories":null,"content":"lib：基础jar包 ","date":"2020-07-14","objectID":"/tomcat/:1:3","tags":["Tomcat"],"title":"Tomcat详解","uri":"/tomcat/"},{"categories":null,"content":"temp ：临时文件 ","date":"2020-07-14","objectID":"/tomcat/:1:4","tags":["Tomcat"],"title":"Tomcat详解","uri":"/tomcat/"},{"categories":null,"content":"webapps ：发布项目的目录，管理界面 ","date":"2020-07-14","objectID":"/tomcat/:1:5","tags":["Tomcat"],"title":"Tomcat详解","uri":"/tomcat/"},{"categories":null,"content":"work：JSP 解析成Java类，中间会产生过程文件，编译运行中间文件 ","date":"2020-07-14","objectID":"/tomcat/:1:6","tags":["Tomcat"],"title":"Tomcat详解","uri":"/tomcat/"},{"categories":null,"content":"架构及原理剖析 ","date":"2020-07-14","objectID":"/tomcat/:2:0","tags":["Tomcat"],"title":"Tomcat详解","uri":"/tomcat/"},{"categories":null,"content":"架构 http请求过程 tomcat是一个http服务器，能够接收http请求 Tomcat Servlet容器处理流程 1.HTTP服务器会把请求信息使用ServletRequest对象封装起来 ; 2.进一步去调用Servlet容器中某个具体Servlet; 3.在 (2)中，Servlet容器拿到请求后，根据URL和Servlet的映射关系，找到相应的Servlet ; 4.如果Servlet还没有被加载，就用反射机制创建这个Servlet，并调用Servlet的init方法来完成初始化 ; 5.接着调用这个具体Servlet的service方法来处理请求，请求处理结果使用ServletResponse对象封装 ; 6.把ServletResponse对象返回给HTTP服务器，HTTP服务器会把响应发送给客户端 总体架构，核心组件 连接器Connector 职责：负责对外交流: 处理Socket连接，负责网络字节流与Request和Response对象的转化; 连接器组件 Coyote 简介 封装网络通信，(Socket 请求及响应处理) Catalina 容器(容器组件)与具体的请求协议及IO操作方式完全解耦 将Socket 输入转换封装为 Request 对象，进一步封装后交由Catalina 容器进行处理，处 理请求完成后, Catalina 通过Coyote 提供的Response 对象将结果写入输出流 Coyote 负责的是具体协议(应用层)和IO(传输层)相关内容 I/O模型及协议 应用层协议 Http/1.1 默认，Web访问协议 AJP：和WX集成（如Apache），已实现对静态资源的优化以及集群部署 HTTP/2 I/O模型（传输层） NIO：非阻塞I/O NIO2:异步I/O，采用JDK 7 NIO2类库 APR ：采用Apache可移植运行库实现 内部组件 EndPoint：通信端点，通信监听接口，Socket接收和发送处理，传输层的抽象，用来实现TCP/IP协议。 Processor：应用层协议抽象，协议处理接口，实现Http协议，接收EndPoint的Socket，读取字节流解析成Tomcat Request和Response对象，通过Adapter提交到容器处理。 ProcessorHandler：Coyote协议接口，通过EndPoint和Processor，实现具体协议的处理能力 Adapter：由于协议不同，客户端发送的请求信息不同，Tomcat定义自己的Request对象，ProcessorHandler解析请求生存Tomcat Request对象，适配器模式，连接器抵用CoyoteAdapter的Service方法，将Tomcat Request 转成ServletRequest，再调用容器 流程 容器Contain 职责：负责内部处理:加载和管理Servlet，以及具体处理Request请求; 容器 Catalina 结构 一个Catalina实例 一个Server实例 包含多个Service服务 多个Container，这里不再是Catalina，Catalina概念提升 Engine：整个Catalina Servlet引擎，一个Service智能有一个Engine Host：代表一个虚拟主机或站点 Context：表示一个Web应用程序 Wrapper：表示一个Servlet，容器的最底层，不能包含子容器 Tomcat分层结构图 Servlet容器 Catalina，核心 连接器Coyote，网络通信 JSP引擎Jasper Naming（命名服务） Juli服务器日志 ","date":"2020-07-14","objectID":"/tomcat/:2:1","tags":["Tomcat"],"title":"Tomcat详解","uri":"/tomcat/"},{"categories":null,"content":"核心配置 ","date":"2020-07-14","objectID":"/tomcat/:3:0","tags":["Tomcat"],"title":"Tomcat详解","uri":"/tomcat/"},{"categories":null,"content":"server.xml Server：根元素，创建一个Server实例 Listener：监听器 VersionLoggerListener：输出服务器，操作系统，JVM版本信息 AprLifecycleListener：加载销毁APR JreMemoryLeakPreventListener：避免JRE内存溢出 GlobalResourcesLifecycleListener： 加载(服务器启动) 和 销毁(服务器停止) 全局命名服务 ThreadLocalLeakPreventionListener：在Context停止时重建 Executor 池中的线程， 以避免ThreadLocal 相关的内存泄漏 GlobalNamingResources：定义服务器全局JNDI资源 Service：服务实例，name= Catalina Connector标签 port: 端口号，Connector 用于创建服务端Socket 并进行监听， 以等待客户端请求链接。如果该属性设置 为0， Tomcat将会随机选择一个可用的端口号给当前Connector 使用 protocol: 当前Connector 支持的访问协议。 默认为 HTTP/1.1 ， 并采用自动切换机制选择一个基于 JAVA NIO 的链接器或者基于本地APR的链接器(根据本地是否含有Tomcat的本地库判定) connectionTimeOut: Connector 接收链接后的等待超时时间， 单位为 毫秒。 -1 表示不超时。 redirectPort: 当前Connector 不支持SSL请求， 接收到了一个请求， 并且也符合security-constraint 约束， 需要SSL传输，Catalina自动将请求重定向到指定的端口。默认：8443 executor:指定共享线程池的名称， 也可以通过maxThreads、minSpareThreads 等属性配置内部线程池。 URIEncoding:用于指定编码URI的字符编码， Tomcat8.x版本默认的编码为 UTF-8 , Tomcat7.x版本默认为ISO-8859-1 Listener标签 Executor标签：共享线程池，可以共享给多个Connector使用 name: 线程池名称，用于 Connector中指定 namePrefix: 所创建的每个线程的名称前缀，一个单独的线程名称为 namePrefix+threadNumber maxThreads: 池中最大线程数 minSpareThreads: 活跃线程数，也就是核心池线程数，这些线程不会被销毁，会一直存在 maxIdleTime:线程空闲时间，超过该时间后，空闲线程会被销毁，默认值为6000(1分钟)，单位毫秒 maxQueueSize:在被执行前最大线程排队数目，默认为Int的最大值，也就是广义的无限。除非特殊情况，这个值 不需要更改，否则会有请求不会被处理的情况发生 prestartminSpareThreads:启动线程池时是否启动 minSpareThreads部分线程。默认值为false，即不启动 threadPriority:线程池中线程优先级，默认值为5，值从1到10 className:线程池实现类，未指定情况下，默认实现类为org.apache.catalina.core.StandardThreadExecutor。如果想使用自定义线程池首先需要实现 org.apache.catalina.Executor接口 Engine标签 name: 用于指定Engine 的名称， 默认为Catalina defaultHost:默认使用的虚拟主机名称， 当客户端请求指向的主机无效时， 将交由默认的虚拟主机处 理， 默认为localhost ","date":"2020-07-14","objectID":"/tomcat/:3:1","tags":["Tomcat"],"title":"Tomcat详解","uri":"/tomcat/"},{"categories":null,"content":"反射机制 ","date":"2020-07-13","objectID":"/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:0:0","tags":["Java基础"],"title":"Java基础-反射机制","uri":"/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"思考 创建一个对象，有哪几种方式? 1、使用new关键字：这是我们最常见的也是最简单的创建对象的方式 2、使用Clone的方法：无论何时我们调用一个对象的clone方法，JVM就会创建一个新的对象，将前面的对象的内容全部拷贝进去 3、使用反序列化：当我们序列化和反序列化一个对象，JVM会给我们创建一个单独的对象 ","date":"2020-07-13","objectID":"/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:1:0","tags":["Java基础"],"title":"Java基础-反射机制","uri":"/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"定义 JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 通俗的讲，反射就是把Java类中的各个部分，映射成一个个的Java对象，拿到这些对象后可以做一些事情。 例如，一个类有：成员变量，方法，构造方法，等信息，利用反射技术咱们可以把这些组成部分映射成一个个对象。 ","date":"2020-07-13","objectID":"/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:2:0","tags":["Java基础"],"title":"Java基础-反射机制","uri":"/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"反射机制的相关类 与Java反射相关的类如下： 类名 用途 Class类 代表类的实体，在运行的Java应用程序中表示类和接口 Field类 代表类的成员变量（成员变量也称为类的属性） Method类 代表类的方法 Constructor类 代表类的构造方法 Class类 Class代表类的实体，在运行的Java应用程序中表示类和接口。在这个类中提供了很多有用的方法，这里对他们简单的分类介绍。 获得类相关的方法 方法 用途 asSubclass(Class clazz) 把传递的类的对象转换成代表其子类的对象 Cast 把对象转换成代表类或是接口的对象 getClassLoader() 获得类的加载器 getClasses() 返回一个数组，数组中包含该类中所有公共类和接口类的对象 getDeclaredClasses() 返回一个数组，数组中包含该类中所有类和接口类的对象 forName(String className) 根据类名返回类的对象 getName() 获得类的完整路径名字 newInstance() 创建类的实例 getPackage() 获得类的包 getSimpleName() 获得类的名字 getSuperclass() 获得当前类继承的父类的名字 getInterfaces() 获得当前类实现的类或是接口 获得类中属性相关的方法 方法 用途 getField(String name) 获得某个公有的属性对象 getFields() 获得所有公有的属性对象 getDeclaredField(String name) 获得某个属性对象 getDeclaredFields() 获得所有属性对象 获得类中注解相关的方法 方法 用途 getAnnotation(Class annotationClass) 返回该类中与参数类型匹配的公有注解对象 getAnnotations() 返回该类所有的公有注解对象 getDeclaredAnnotation(Class annotationClass) 返回该类中与参数类型匹配的所有注解对象 getDeclaredAnnotations() 返回该类所有的注解对象 获得类中构造器相关的方法 方法 用途 getConstructor(Class…\u003c?\u003e parameterTypes) 获得该类中与参数类型匹配的公有构造方法 getConstructors() 获得该类的所有公有构造方法 getDeclaredConstructor(Class…\u003c?\u003e parameterTypes) 获得该类中与参数类型匹配的构造方法 getDeclaredConstructors() 获得该类所有构造方法 获得类中方法相关的方法 方法 用途 getMethod(String name, Class…\u003c?\u003e parameterTypes) 获得该类某个公有的方法 getMethods() 获得该类所有公有的方法 getDeclaredMethod(String name, Class…\u003c?\u003e parameterTypes) 获得该类某个方法 getDeclaredMethods() 获得该类所有方法 类中其他重要的方法 方法 用途 isAnnotation() 如果是注解类型则返回true isAnnotationPresent(Class\u003c? extends Annotation\u003e annotationClass) 如果是指定类型注解类型则返回true isAnonymousClass() 如果是匿名类则返回true isArray() 如果是一个数组类则返回true isEnum() 如果是枚举类则返回true isInstance(Object obj) 如果obj是该类的实例则返回true isInterface() 如果是接口类则返回true isLocalClass() 如果是局部类则返回true isMemberClass() 如果是内部类则返回true Field类 Field代表类的成员变量（成员变量也称为类的属性）。 方法 用途 equals(Object obj) 属性与obj相等则返回true get(Object obj) 获得obj中对应的属性值 set(Object obj, Object value) 设置obj中对应属性值 Method类 Method代表类的方法。 方法 用途 invoke(Object obj, Object… args) 传递object对象及参数调用该对象对应的方法 Constructor类 Constructor代表类的构造方法。 方法 用途 newInstance(Object… initargs) 根据传递的参数创建类的对象 示例 为了演示反射的使用，首先构造一个与书籍相关的model——Book.java，然后通过反射方法示例创建对象、反射私有构造方法、反射私有属性、反射私有方法，最后给出两个比较复杂的反射示例——获得当前ZenMode和关机Shutdown。 被反射类Book.java public class Book{ private final static String TAG = \"BookTag\"; private String name; private String author; @Override public String toString() { return \"Book{\" + \"name='\" + name + '\\'' + \", author='\" + author + '\\'' + '}'; } public Book() { } private Book(String name, String author) { this.name = name; this.author = author; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } private String declaredMethod(int index) { String string = null; switch (index) { case 0: string = \"I am declaredMethod 1 !\"; break; case 1: string = \"I am declaredMethod 2 !\"; break; default: string = \"I am declaredMethod 1 !\"; } return string; } } 反射逻辑封装在ReflectClass.java public class ReflectClass { private final static String TAG = \"peter.log.ReflectClass\"; // 创建对象 public static void reflectNewInstance() { try { Class\u003c?\u003e classBook = Class.forName(\"com.android.peter.reflectdemo.Book\"); Object objectBook = classBook.newInstance(); Book book = (Book) objectBook; book.setName(\"Android进阶之光\"); book.setAuthor(\"刘望舒\"); Log.d(TAG,\"reflectNewInstance book = \" + book.toString()); } catch (Exception ex) { ex.printStackTrace(); } } // 反射私有的构造方法 public static void reflectPrivateConstructor() { try { Class\u003c?\u003e classBook = Class.forName(\"com.android.peter.reflectdemo.Book\"); Constructor\u003c?\u003e declaredConstructorBook = classBook.getDeclaredConstructor(String.class,String.class); declaredConstructorBook.setAccessible(true); Object objectBook = declaredConstructorBook.newInstance(\"Android开发艺术探索\",\"任玉刚\"); Book book = (Book) objectBook; Log.d(TAG,\"reflectPrivateConstructor book = \" + book.toString()); } catch (Exception ex) { ex.printStackTrace(); } } // 反射私有属性 public static void reflectPrivateField() { try { Class\u003c?\u003e classBook = Class.","date":"2020-07-13","objectID":"/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/:3:0","tags":["Java基础"],"title":"Java基础-反射机制","uri":"/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"理解代理模式、静态代理、动态代理、CGlib、AOP ","date":"2020-07-13","objectID":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/:0:0","tags":["设计模式","代理"],"title":"理解代理模式、静态代理、动态代理、CGlib、AOP","uri":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/"},{"categories":null,"content":"代理模式 ","date":"2020-07-13","objectID":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/:1:0","tags":["设计模式","代理"],"title":"理解代理模式、静态代理、动态代理、CGlib、AOP","uri":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/"},{"categories":null,"content":"定义 为其他对象提供一种代理以控制对这个对象的访问。在某些情况下，一个对象不适合或者不能直接引用另一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。 ","date":"2020-07-13","objectID":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/:1:1","tags":["设计模式","代理"],"title":"理解代理模式、静态代理、动态代理、CGlib、AOP","uri":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/"},{"categories":null,"content":"组成 抽象角色：通过接口或抽象类声明真实角色实现的业务方法。 代理角色：实现抽象角色，是真实角色的代理，通过真实角色的业务逻辑方法来实现抽象方法，并可以附加自己的操作。 真实角色：实现抽象角色，定义真实角色所要实现的业务逻辑，供代理角色调用。 ","date":"2020-07-13","objectID":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/:1:2","tags":["设计模式","代理"],"title":"理解代理模式、静态代理、动态代理、CGlib、AOP","uri":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/"},{"categories":null,"content":"优点 (1).职责清晰 真实的角色就是实现实际的业务逻辑，不用关心其他非本职责的事务，通过后期的代理完成一件完成事务，附带的结果就是编程简洁清晰。 (2).代理对象可以在客户端和目标对象之间起到中介的作用，这样起到了中介的作用和保护了目标对象的作用。 (3).高扩展性 ","date":"2020-07-13","objectID":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/:1:3","tags":["设计模式","代理"],"title":"理解代理模式、静态代理、动态代理、CGlib、AOP","uri":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/"},{"categories":null,"content":"应用场景 （1）最经典的就是Spring AOP的实现，通过代理实现了日志记录，事务，方法耗时等非核心业务本职责的功能的统一控制。 （2）在Hibernate类似相关的框架中，仅仅定义接口就可以通过代理动态实现CURD相关操作。 （3）其他各种字节码操纵的场景。 ","date":"2020-07-13","objectID":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/:1:4","tags":["设计模式","代理"],"title":"理解代理模式、静态代理、动态代理、CGlib、AOP","uri":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/"},{"categories":null,"content":"Java 代理模式实现方式，主要有如下五种方法 静态代理，工程师编辑代理类代码，实现代理模式；在编译期就生成了代理类。 基于 JDK 实现动态代理，通过jdk提供的工具方法Proxy.newProxyInstance动态构建全新的代理类(继承Proxy类，并持有InvocationHandler接口引用 )字节码文件并实例化对象返回。(jdk动态代理是由java内部的反射机制来实例化代理对象，并代理的调用委托类方法) 基于CGlib 动态代理模式 基于继承被代理类生成代理子类，不用实现接口。只需要被代理类是非final 类即可。(cglib动态代理底层是借助asm字节码技术） 基于 Aspectj 实现动态代理（修改目标类的字节，织入代理的字节，在程序编译的时候 插入动态代理的字节码，不会生成全新的Class ） 基于 instrumentation 实现动态代理（修改目标类的字节码、类装载的时候动态拦截去修改，基于javaagent） -javaagent:spring-instrument-4.3.8.RELEASE.jar （类装载的时候 插入动态代理的字节码，不会生成全新的Class ） ","date":"2020-07-13","objectID":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/:1:5","tags":["设计模式","代理"],"title":"理解代理模式、静态代理、动态代理、CGlib、AOP","uri":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/"},{"categories":null,"content":"Notes 委托类 即指的是代理模式中的被代理对象 代理类 指的是生成的代表委托类的一个角色 ","date":"2020-07-13","objectID":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/:1:6","tags":["设计模式","代理"],"title":"理解代理模式、静态代理、动态代理、CGlib、AOP","uri":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/"},{"categories":null,"content":"静态代理实现 静态代理是代理类在编译期间就创建好了，不是编译器生成的代理类，而是手动创建的类。在编译时就已经将接口，被代理类，代理类等确定下来。，软件设计中所指的代理一般是指静态代理，也就是在代码中显式指定的代理。 ","date":"2020-07-13","objectID":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/:2:0","tags":["设计模式","代理"],"title":"理解代理模式、静态代理、动态代理、CGlib、AOP","uri":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/"},{"categories":null,"content":"实现步骤 委托类和代理类之间的约束接口Cat 约束接口实现类 Lion，实现 Cat 接口，委托角色 代理类实现 FeederProxy，实现Cat 接口，并含有一个 Cat接口引用属性。 代理角色，代理 cat接口属性引用实例的行为并可以新增公共逻辑 委托类Cat public interface Cat { public String eatFood(String foodName); public boolean running(); } 实现类Lion public class Lion implements Cat { private String name; private int runningSpeed; public String getName() { return name; } public void setName(String name) { this.name = name; } public int getRunningSpeed() { return runningSpeed; } public void setRunningSpeed(int runningSpeed) { this.runningSpeed = runningSpeed; } public Lion() { } @Override public String eatFood(String foodName) { String eat = this.name + \" Lion eat food. foodName = \" + foodName; System.out.println(eat); return eat; } @Override public boolean running() { System.out.println(this.name + \" Lion is running . Speed :\" + this.runningSpeed); return false; } } 代理类FeederProxy public class FeederProxy implements Cat { private Cat cat; public FeederProxy() { } public FeederProxy(Cat cat) { if (cat instanceof Cat) { this.cat = cat; } } public void setCat(Cat cat) { if (cat instanceof Cat) { this.cat = cat; } } @Override public String eatFood(String foodName) { System.out.println(\"proxy Lion exec eatFood \"); return cat.eatFood(foodName); } @Override public boolean running() { System.out.println(\"proxy Lion exec running.\"); return cat.running(); } } 测试 public class StaticProxyTest { public static void main(String[] args) { Lion lion = new Lion(); lion.setName(\"狮子 小王\"); lion.setRunningSpeed(100); /** * new 静态代理类，静态代理类在编译前已经创建好了，和动态代理的最大区别点 */ Cat proxy = new FeederProxy(lion); System.out.println(Thread.currentThread().getName() + \" -- \" + proxy.eatFood(\"水牛\")); proxy.running(); } } 静态代理很好的诠释了代理设计模式，代理模式最主要的就是有一个公共接口（Cat），一个委托类（Lion），一个代理类（FeederProxy）,代理类持有委托类的实例，代为执行具体类实例方法。 上面说到，代理模式就是在访问实际对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。这里的间接性就是指客户端不直接调用实际对象的方法，客户端依赖公共接口并使用代理类。 那么我们在代理过程中就可以加上一些其他用途。 就这个例子来说在 eatFood方法调用中，代理类在调用具体实现类之前添加System.out.println(\"proxy Lion exec eatFood \");语句 就是添加间接性带来的收益。代理类存在的意义是为了增加一些公共的逻辑代码。 ","date":"2020-07-13","objectID":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/:2:1","tags":["设计模式","代理"],"title":"理解代理模式、静态代理、动态代理、CGlib、AOP","uri":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/"},{"categories":null,"content":"动态代理类(基于接口实现) 静态代理是代理类在代码运行前已经创建好，并生成class文件；动态代理类 是代理类在程序运行时创建的代理模式。 动态代理类的代理类并不是在Java代码中定义的，而是在运行时根据我们在Java代码中的“指示”动态生成的。相比于静态代理， 动态代理的优势在于可以很方便的对代理类的函数进行统一的处理，而不用修改每个代理类中的方法。 想想你有100个静态代理类，现在有一个需求，每个代理类都需要新增一个处理逻辑，你需要打开100个代理类在每个代理方法里面新增处理逻辑吗？ 有或者代理类有5个方法，每个方法都需要新增一个处理逻辑， 你需要在每个方法都手动新增处理逻辑吗？ 想想就挺无趣的。动态代理类帮你一键搞定。 ","date":"2020-07-13","objectID":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/:3:0","tags":["设计模式","代理"],"title":"理解代理模式、静态代理、动态代理、CGlib、AOP","uri":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/"},{"categories":null,"content":"动态代理类涉及角色 委托类和代理类实现的公共接口(Person.java) 实现公共接口的具体委托类(SoftwareEngineer.java) InvocationHandler接口被Proxy类回调处理，一般实现 InvocationHandler 接口的类具有委托类引用，接口方法 invoke 中添加公共代码并调用委托类的接口方法。(PersonInvocationHandler.java) JDK提供生成动态代理类的核心类Proxy ( JDK 提供的Proxy.java) ","date":"2020-07-13","objectID":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/:3:1","tags":["设计模式","代理"],"title":"理解代理模式、静态代理、动态代理、CGlib、AOP","uri":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/"},{"categories":null,"content":"JDK技术动态代理类 技术核心: Proxy类和一个 InvocationHandler 接口 java的java.lang.reflect包下提供了Proxy类和一个 InvocationHandler 接口，这个类Proxy定义了生成JDK动态代理类的方法 getProxyClass(ClassLoader loader,Class\u003c?\u003e... interfaces)生成动态代理类,返回class实例代表一个class文件。可以保存该 class文件查看jdk生成的代理类文件长什么样 该生成的动态代理类继承Proxy类，(重要特性) ，并实现公共接口。 InvocationHandler这个接口 是被动态代理类回调的接口，我们所有需要增加的针对委托类的统一处理逻辑都增加到invoke 方法里面在调用委托类接口方法之前或之后 结束战斗。 案例 公共接口 /** * 创建Person 接口 用于定义 委托类和代理类之间的约束行为 */ public interface Person{ /** * * @param name 人名 * @param dst 工作目的地 */ void goWorking(String name, String dst); /** * 获取名称 * @return */ String getName( ); /** * 设置名称 * @param name */ void setName(String name); } 具体实现类，等下被委托，被代理的类 SoftwareEngineer.java /** * 动态代理委托类实现， 实现接口 Person。 被动态生成的代理类代理 */ public class SoftwareEngineer implements Person { public SoftwareEngineer() { } public SoftwareEngineer(String name) { this.name = name; } private String name; public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public void goWorking(String name, String dst) { System.out.println(\"name =\" + name + \" ， 去 \" + dst + \" 工作\"); } } InvocationHandler 接口实现 PersonInvocationHandler.java import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.util.Arrays; /** * PersonInvocationHandler 类 实现InvocationHandler接口，这个类中持有一个被代理对象(委托类)的实例target。 * 该类别JDK Proxy类回调InvocationHandler 接口中有一个invoke方法，当一个代理实例的方法被调用时，代理方法将被编码并分发到 * * InvocationHandler接口的invoke方法执行。 */ public class PersonInvocationHandler\u003cT\u003e implements InvocationHandler { /** * 被代理对象引用，invoke 方法里面method 需要使用这个 被代理对象 */ T target; public PersonInvocationHandler(T target) { this.target = target; } /** * * @param proxy 代表动态生成的 动态代理 对象实例 * @param method 代表被调用委托类的接口方法，和生成的代理类实例调用的接口方法是一致的，它对应的Method 实例 * @param args 代表调用接口方法对应的Object参数数组，如果接口是无参，则为null； 对于原始数据类型返回的他的包装类型。 * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { /** * 在转调具体目标对象之前，可以执行一些功能处理 */ System.out.println(\"被动态代理类回调执行, 代理类 proxyClass =\" + proxy.getClass() + \" 方法名: \" + method.getName() + \"方法. 方法返回类型：\" + method.getReturnType() + \" 接口方法入参数组: \" + (args == null ? \"null\" : Arrays.toString(args))); /** * 代理过程中插入监测方法,计算该方法耗时 */ MonitorUtil.start(); Thread.sleep(1); /** 调用呗代理对象的真实方法，*/ Object result = method.invoke(target, args); MonitorUtil.finish(method.getName()); return result; } } PersonInvocationHandler invoke 方法中添加的公共代码，这里简单以统计方法执行时间为逻辑 /** * 方法用时监控类 */ public class MonitorUtil { private static ThreadLocal\u003cLong\u003e tl = new ThreadLocal\u003c\u003e(); public static void start() { tl.set(System.currentTimeMillis()); } /** * 结束时打印耗时 * * @param methodName 方法名 */ public static void finish(String methodName) { long finishTime = System.currentTimeMillis(); System.out.println(methodName + \"方法执行耗时\" + (finishTime - tl.get()) + \"ms\"); } } 最后的是 怎么创建代理类 import org.vincent.proxy.dynamicproxy.Person; import org.vincent.proxy.dynamicproxy.PersonInvocationHandler; import org.vincent.proxy.dynamicproxy.SoftwareEngineer; import sun.misc.ProxyGenerator; import java.io.FileOutputStream; import java.lang.reflect.Constructor; import java.lang.reflect.Field; import java.lang.reflect.InvocationHandler; import java.lang.reflect.Proxy; import java.nio.file.Path; import java.nio.file.Paths; import java.util.Arrays; import java.util.Properties; public class JdkDynamicProxyTest { public static void main(String[] args) throws Exception { // 打开保存JDK动态代理生成的类文件 saveGeneratedJdkProxyFiles(); /** * 第一种方法: 通过 Proxy.newProxyInstance 方法 获取代理对象 */ System.out.println(\"-------------------第一种创建代理类方法--------------\"); //创建一个实例对象，这个对象是被代理的对象，委托类 Person person = new SoftwareEngineer(\"Vincent\"); //创建一个与代理类相关联的InvocationHandler,每一个代理类都有一个关联的 InvocationHandler，并将代理类引用传递进去 InvocationHandler Handler = new PersonInvocationHandler\u003c\u003e(person); //创建一个 代理对象 personProxy 来代理 person，创建的代理对象的每个执行方法都会被替换执行Invocation接口中的invoke方法 Person personProxy = (Person) Proxy.newProxyInstance(Person.class.getClassLoader(), new Class\u003c?\u003e[]{Person.class}, H","date":"2020-07-13","objectID":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/:3:2","tags":["设计模式","代理"],"title":"理解代理模式、静态代理、动态代理、CGlib、AOP","uri":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/"},{"categories":null,"content":"基于CGlib 技术动态代理代理类实现 (基于继承) Cglib是针对类来实现代理的，他的原理是对代理的目标类生成一个子类，并覆盖其中方法实现增强，因为底层是基于创建被代理类的一个子类，所以它避免了JDK动态代理类的缺陷。 但因为采用的是继承，所以不能对final修饰的类进行代理。final修饰的类不可继承。 导入maven 依赖 cglib 是基于asm 字节修改技术。导入 cglib 会间接导入 asm, ant, ant-launcher 三个jar 包。 \u003c!-- cglib 动态代理依赖 begin --\u003e \u003cdependency\u003e \u003cgroupId\u003ecglib\u003c/groupId\u003e \u003cartifactId\u003ecglib\u003c/artifactId\u003e \u003cversion\u003e3.2.5\u003c/version\u003e \u003c/dependency\u003e \u003c!-- cglib 动态代理依赖 stop --\u003e 业务类实现 cglib是针对类来实现代理的，原理是对指定的业务类生成他的一个子类，并覆盖其中的业务方法来实现代理。因为采用的是继承，所以不能对final修饰的类进行代理。 public class Dog { public String call() { System.out.println(\"wang wang wang\"); return \"Dog ..\"; } } 方法拦截器 实现 MethodInterceptor 接口 import net.sf.cglib.proxy.Enhancer; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; public class CglibMethodInterceptor implements MethodInterceptor { /** * 用于生成 Cglib 动态代理类工具方法 * * @param target 代表需要 被代理的 委托类的 Class 对象 * @return */ public Object CglibProxyGeneratory(Class target) { /** 创建cglib 代理类 start */ // 创建加强器，用来创建动态代理类 Enhancer enhancer = new Enhancer(); // 为代理类指定需要代理的类，也即是父类 enhancer.setSuperclass(target); // 设置方法拦截器回调引用，对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept() 方法进行拦截 enhancer.setCallback(this); // 获取动态代理类对象并返回 return enhancer.create(); /** 创建cglib 代理类 end */ } /** * 功能主要是在调用业务类方法之前 之后添加统计时间的方法逻辑. * intercept 因为 具有 MethodProxy proxy 参数的原因 不再需要代理类的引用对象了, 直接通过proxy 对象访问被代理对象的方法(这种方式更快)。 * 当然 也可以通过反射机制，通过 method 引用实例 Object result = method.invoke(target, args); 形式反射调用被代理类方法， * target 实例代表被代理类对象引用, 初始化 CglibMethodInterceptor 时候被赋值 。但是Cglib不推荐使用这种方式 * * @param obj 代表Cglib 生成的动态代理类 对象本身 * @param method 代理类中被拦截的接口方法 Method 实例 * @param args 接口方法参数 * @param proxy 用于调用父类真正的业务类方法。可以直接调用被代理类接口方法 * @return * @throws Throwable */ @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable { System.out.println(\"before\"); MonitorUtil.start(); Object result = proxy.invokeSuper(obj, args); //Object result = method.invoke(target, args); System.out.println(\"after\"); MonitorUtil.finish(method.getName()); return result; } } 一个切面，用于在方法拦截器中intercept 方法中调用真正业务方法之前 之后处理逻辑 public class MonitorUtil { private static ThreadLocal\u003cLong\u003e tl = new ThreadLocal\u003c\u003e(); public static void start() { tl.set(System.currentTimeMillis()); } /** * 结束时打印耗时 * @param methodName 方法名 */ public static void finish(String methodName) { long finishTime = System.currentTimeMillis(); System.out.println(methodName + \"方法执行耗时\" + (finishTime - tl.get()) + \"ms\"); } } Cglib测试类 import net.sf.cglib.core.DebuggingClassWriter; import net.sf.cglib.proxy.Enhancer; import org.junit.Test; import java.lang.reflect.Field; import java.util.Properties; public class CglibTest { @Test public void testCglib() throws Exception { System.out.println(System.getProperty(\"user.dir\")); /** 开启 保存cglib生成的动态代理类类文件*/ saveGeneratedCGlibProxyFiles(System.getProperty(\"user.dir\")); /** 第一种方法: 创建cglib 代理类 start */ // 创建加强器，用来创建动态代理类 Enhancer enhancer = new Enhancer(); // 为代理类指定需要代理的类，也即是父类 enhancer.setSuperclass(Dog.class); // new 一个新的方法拦截器 CglibMethodInterceptor cglibMethodInterceptor = new CglibMethodInterceptor(); // 设置方法拦截器回调引用，对于代理类上所有方法的调用，都会调用CallBack，而Callback则需要实现intercept() 方法进行拦截 enhancer.setCallback(cglibMethodInterceptor); // 获取动态代理类对象并返回 Dog dog = (Dog) enhancer.create(); /** 创建cglib 代理类 end */ System.out.println(dog.call()); // 对于上面这几步，可以新增一个工具方法 放置在 CglibMethodInterceptor 里面；也就有了第二种方法 // new 一个新的方法拦截器，该拦截器还顺带一个用于创建代理类的工具方法。看起来简单很多 cglibMethodInterceptor = new CglibMethodInterceptor(); dog = (Dog) cglibMethodInterceptor.CglibProxyGeneratory(Dog.class); System.out.println(dog.call()); } /** * 设置保存Cglib代理生成的类文件。 * * @throws Exception */ public void saveGeneratedCGlibProxyFiles(String dir) throws Exception { Field field = System.class.getDeclaredField(\"props\"); field.setAccessible(true); Properties props = (Properties) field.get(null); System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, dir);//dir为保存文件路径 props.put(\"net.sf.cglib.core.DebuggingClassWriter.","date":"2020-07-13","objectID":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/:3:3","tags":["设计模式","代理"],"title":"理解代理模式、静态代理、动态代理、CGlib、AOP","uri":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/"},{"categories":null,"content":"静态代理 基于JDK动态代理 基于Cglib 动态代理 静态代理是通过在代码中显式编码定义一个业务实现类的代理类，在代理类中对同名的业务方法进行包装，用户通过代理类调用被包装过的业务方法； JDK动态代理是通过接口中的方法名，在动态生成的代理类中调用业务实现类的同名方法； CGlib动态代理是通过继承业务类，生成的动态代理类是业务类的子类，通过重写业务方法进行代理； 静态代理在编译时产生class字节码文件，可以直接使用，效率高。动态代理必须实现InvocationHandler接口，通过invoke调用被委托类接口方法是通过反射方式，比较消耗系统性能，但可以减少代理类的数量，使用更灵活。 cglib代理无需实现接口，通过生成类字节码实现代理，比反射稍快，不存在性能问题，但cglib会继承目标对象，需要重写方法，所以目标对象不能为final类。 ","date":"2020-07-13","objectID":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/:4:0","tags":["设计模式","代理"],"title":"理解代理模式、静态代理、动态代理、CGlib、AOP","uri":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/"},{"categories":null,"content":"AOP 实现案例 AOP的源码中用到了两种动态代理来实现拦截切入功能：jdk动态代理和cglib动态代理。两种方法同时存在，各有优劣。 jdk动态代理是由java内部的反射机制来实现的，cglib动态代理底层则是借助asm来实现的。 总的来说，反射机制在生成类的过程中比较高效，执行时候通过反射调用委托类接口方法比较慢；而asm在生成类之后的相关代理类执行过程中比较高效（可以通过将asm生成的类进行缓存，这样解决asm生成类过程低效问题）。 还有一点必须注意：jdk动态代理的应用前提，必须是委托类基于统一的接口。如果没有上述前提，jdk动态代理不能应用。 由此可以看出，jdk动态代理有一定的局限性，cglib这种第三方类库实现的动态代理应用更加广泛，且在效率上更有优势。 实现AOP关键特点是定义好两个角色 切点 和 切面 。 代理模式中被代理类 委托类处于切点角色，需要添加的其他比如 校验逻辑，事务，审计逻辑 属于非功能实现逻辑通过 切面类定义的方法插入进去。 ","date":"2020-07-13","objectID":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/:5:0","tags":["设计模式","代理"],"title":"理解代理模式、静态代理、动态代理、CGlib、AOP","uri":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/"},{"categories":null,"content":"JDK动态代理 aop 实现方式 定义切面接口，完成将通用公共方法注入到被代理类接口调用处理中 public interface IAspect { /** * 在切点接口方法执行之前执行 * @param args 切点参数列表 * @return */ boolean startTransaction(Object... args); /** * 在切点接口方法执行之后执行 */ void endTrasaction(); } 定义切面实现类 import java.util.Objects; public class CustomAspect implements IAspect { /** * 对参数 做判空处理 * * @param args 切点参数列表 * @return */ @Override public boolean startTransaction(Object... args) { Objects.nonNull(args); boolean result = true; for (Object temp : args) { if (Objects.isNull(temp)) { result = false; break; } } return result; } public void endTrasaction() { System.out.println(\"I get datasource here and end transaction\"); } } 定义切点角色接口 因为是基于JDK实现的Aop ，所以委托类需要基于接口实现。 public interface IUserService { void saveUser(String username, String password) throws Exception; } 委托类实现 public class UserServiceImpl implements IUserService{ @Override public void saveUser(String username, String password) throws Exception { System.out.println(\"save user[username=\" + username + \",password=\" + password + \"]\"); } } JDK动态代理生成器工具类 可以看到 generatorJDKProxy 方法入参只有两个参数 一个切点接口引用，一个切面接口引用；在InvocationHandler 内部类中可以完整看到切面类方法是怎么影响切点代码执行逻辑的。 import java.lang.reflect.InvocationHandler; import java.lang.reflect.Method; import java.lang.reflect.Proxy; import java.util.Arrays; public class JDKDynamicProxyGenerator { /** * @param targetPoint 需要被代理的委托类对象 * @param aspect 切面对象,该对象方法将在切点方法之前或之后执行 * @return */ public static Object generatorJDKProxy(IUserService targetPoint, final IAspect aspect) { return Proxy.newProxyInstance( /** * 委托类使用的类加载器 */ targetPoint.getClass().getClassLoader(), /** * 委托类实现的接口 */ targetPoint.getClass().getInterfaces(), /** * 生成的动态代理类关联的 执行处理器，代理我们的业务逻辑被生成的动态代理类回调 * 具体逻辑代码执行,返回值为方法执行结果, 在aop模型中，委托类的接口方法称为切点。 */ new InvocationHandler() { @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { // 执行切面方法,对入参进行校验 boolean prepareAction = aspect.startTransaction(args); if (prepareAction) { // 具体逻辑代码执行,返回值为方法执行结果 Object result = method.invoke(targetPoint, args); aspect.endTrasaction(); return result; } else { throw new RuntimeException(\"args: \" + Arrays.toString(args) + \"不能为null \"); } } }); } } 测试类 import org.junit.Test; import org.vincent.aop.dynamicproxy.CustomAspect; import org.vincent.aop.dynamicproxy.IUserService; import org.vincent.aop.dynamicproxy.JDKDynamicProxyGenerator; import org.vincent.aop.dynamicproxy.UserServiceImpl; public class testAopJDKProxy { @Test public void testJDKProxy() throws Exception { System.out.println(\"无代理前 调用方法 userService.saveUser 输出......\"); IUserService userService = new UserServiceImpl(); userService.saveUser(\"zby\", \"1234567890\"); System.out.println(\"有代理后AOP 是怎么样的？ Proxy......\"); IUserService proxyUserService = (IUserService) JDKDynamicProxyGenerator.generatorJDKProxy(userService, new CustomAspect()); proxyUserService.saveUser(\"zby\", \"1234567890\"); /** 制造异常,两个入参都是null */ proxyUserService.saveUser(null, null); } } ","date":"2020-07-13","objectID":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/:5:1","tags":["设计模式","代理"],"title":"理解代理模式、静态代理、动态代理、CGlib、AOP","uri":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/"},{"categories":null,"content":"Cglib aop 实现方式 定义切面接口 public interface IAspect { /** * 在切点接口方法执行之前执行 */ void startTransaction(); /** * 在切点接口方法执行之后执行 */ void endTrasaction(); } 切面实现 public class CustomAspect implements IAspect { @Override public void startTransaction() { System.out.println(\"cglib. I get datasource here and start transaction\"); } public void endTrasaction() { System.out.println(\"cglib I get datasource here and end transaction\"); } } Cglib 是基于类实现的动态代理即业务类只需要实现类即可，不用强制必须实现某个接口为了突出这个优点这里没有实现接口 public class UserServiceImpl { public void saveUser(String username, String password) { System.out.println(\"cglib save user[username=\" + username + \",password=\" + password + \"]\"); } } Cglib 动态代理生成器工具类 import net.sf.cglib.proxy.Enhancer; import net.sf.cglib.proxy.MethodInterceptor; import net.sf.cglib.proxy.MethodProxy; import java.lang.reflect.Method; public class CglibProxyGenerator { /** * @param target 需要被代理的委托类对象，Cglib需要继承该类生成子类 * @param aspect 切面对象,改对象方法将在切点方法之前或之后执行 * @return */ public static Object generatorCglibProxy(final Object target, final IAspect aspect) { //3.1 new Enhancer Enhancer enhancer = new Enhancer(); //3.2 设置需要代理的父类 enhancer.setSuperclass(target.getClass()); //3.3 设置回调 enhancer.setCallback(new MethodInterceptor() { @Override public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { // 执行切面方法 aspect.startTransaction(); // 具体逻辑代码执行,返回值为方法执行结果 Object result = methodProxy.invokeSuper(proxy, args); // 执行切面方法 aspect.endTrasaction(); // 返回方法执行结果 return result; } }); // 3.4 创建代理对象 return enhancer.create(); } } 测试类 import org.junit.Test; import org.vincent.aop.cglib.CglibProxyGenerator; import org.vincent.aop.cglib.CustomAspect; import org.vincent.aop.cglib.UserServiceImpl; public class testAopCglibKProxy { @Test public void testCglibProxy() { System.out.println(\"before Proxy......\"); UserServiceImpl userService = new UserServiceImpl(); userService.saveUser(\"zby\", \"1234567890\"); System.out.println(\"引入Cglib Proxy代理库 后......\"); UserServiceImpl proxyUserService = (UserServiceImpl) CglibProxyGenerator.generatorCglibProxy(userService, new CustomAspect()); proxyUserService.saveUser(\"zby\", \"1234567890\"); } } ","date":"2020-07-13","objectID":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/:5:2","tags":["设计模式","代理"],"title":"理解代理模式、静态代理、动态代理、CGlib、AOP","uri":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/"},{"categories":null,"content":"AspectJ 实现 AOP 效果 AOP 实现的关键就在于 AOP 框架自动创建的 AOP 代理，AOP 代理则可分为静态代理和动态代理两大类: 静态代理是指使用 AOP 框架提供的命令进行编译，从而在编译阶段通过AOP框架指令生成 AOP 代理类，因此也称为编译时增强；还有一种静态代理是编写代码实现不用工具；这种方式一般是代理模式会使用。 动态代理则在运行时借助于 JDK 动态代理、CGLIB 等在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。 基于 AspectJ 的编译时增强进行 AOP POM 依赖 原生 AspectJ 不依赖Spring案例, 基于 AspectJ 的编译时增强进行 AOP 它是在编译期修改字节码，增强功能；并不会生成新的代理类字节码。 \u003c!-- AspectJ begin--\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjrt\u003c/artifactId\u003e \u003cversion\u003e1.9.2\u003c/version\u003e \u003c/dependency\u003e \u003cdependency\u003e \u003cgroupId\u003eorg.aspectj\u003c/groupId\u003e \u003cartifactId\u003easpectjweaver\u003c/artifactId\u003e \u003cversion\u003e1.9.2\u003c/version\u003e \u003c/dependency\u003e \u003c!-- AspectJ stop--\u003e ","date":"2020-07-13","objectID":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/:5:3","tags":["设计模式","代理"],"title":"理解代理模式、静态代理、动态代理、CGlib、AOP","uri":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/"},{"categories":null,"content":"动态代理 使用场景 日志集中打印 事务 权限管理 AOP 原文：https://cloud.tencent.com/developer/article/1461796 ","date":"2020-07-13","objectID":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/:6:0","tags":["设计模式","代理"],"title":"理解代理模式、静态代理、动态代理、CGlib、AOP","uri":"/%E7%90%86%E8%A7%A3%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86cglibaop/"},{"categories":null,"content":"Linux常用命令 ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:0","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"1、ls命令 就是 list 的缩写，通过 ls 命令不仅可以查看 linux 文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。 常用参数搭配： ls -a 列出目录所有文件，包含以.开始的隐藏文件 ls -A 列出除.及..的其它文件 ls -r 反序排列 ls -t 以文件修改时间排序 ls -S 以文件大小排序 ls -h 以易读大小显示 ls -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来 实例： (1) 按易读方式按时间反序排序，并显示文件详细信息 ls -lhrt (2) 按大小反序显示文件详细信息 ls -lrS (3)列出当前目录中所有以\"t\"开头的目录的详细内容 ls -l t* (4) 列出文件绝对路径（不包含隐藏文件） ls|sed\"s:^:`pwd`/:\" (5) 列出文件绝对路径（包含隐藏文件） find $pwd -maxdepth 1 | xargs ls -ld ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:1","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"2、cd 命令 cd(changeDirectory) 命令语法： cd [目录名] 说明：切换当前目录至 dirName。 实例： （1）进入要目录 cd / （2）进入 “home” 目录 cd ~ （3）进入上一次工作路径 cd - （4）把上个命令的参数作为cd参数使用。 cd !$ ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:2","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"3、pwd 命令 pwd 命令用于查看当前工作目录路径。 实例： （1）查看当前路径 pwd （2）查看软链接的实际路径 pwd -P 4、mkdir 命令 mkdir 命令用于创建文件夹。 可用选项： -m: 对新建目录设置存取权限，也可以用 chmod 命令设置; -p: 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后，系统将自动建立好那些尚不在的目录，即一次可以建立多个目录。 实例： （1）当前工作目录下创建名为 t的文件夹 mkdir t （2）在 tmp 目录下创建路径为 test/t1/t 的目录，若不存在，则创建： mkdir -p /tmp/test/t1/t ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:3","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"5、rm 命令 删除一个目录中的一个或多个文件或目录，如果没有使用 -r 选项，则 rm 不会删除目录。如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。 rm [选项] 文件… 实例： （1）删除任何 .log 文件，删除前逐一询问确认： rm -i *.log （2）删除 test 子目录及子目录中所有档案删除，并且不用一一确认： rm -rf test （3）删除以 -f 开头的文件 rm -- -f* ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:4","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"6、rmdir 命令 从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对其父目录的写权限。 注意：不能删除非空目录 实例： （1）当 parent 子目录被删除后使它也成为空目录的话，则顺便一并删除： rmdir -p parent/child/child11 ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:5","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"7、mv 命令 移动文件或修改文件名，根据第二参数类型（如目录，则移动文件；如为文件则重命令该文件）。 当第二个参数为目录时，第一个参数可以是多个以空格分隔的文件或目录，然后移动第一个参数指定的多个文件到第二个参数指定的目录中。 实例： （1）将文件 test.log 重命名为 test1.txt mv test.log test1.txt （2）将文件 log1.txt,log2.txt,log3.txt 移动到根的 test3 目录中 mv llog1.txt log2.txt log3.txt /test3 （3）将文件 file1 改名为 file2，如果 file2 已经存在，则询问是否覆盖 mv -i log1.txt log2.txt （4）移动当前文件夹下的所有文件到上一级目录 mv * ../ ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:6","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"8、cp 命令 将源文件复制至目标文件，或将多个源文件复制至目标目录。 注意：命令行复制，如果目标文件已经存在会提示是否覆盖，而在 shell 脚本中，如果不加 -i 参数，则不会提示，而是直接覆盖！ -i 提示 -r 复制目录及目录内所有项目 -a 复制的文件与原文件时间一样 实例： （1）复制 a.txt 到 test 目录下，保持原文件时间，如果原文件存在提示是否覆盖。 cp -ai a.txt test （2）为 a.txt 建议一个链接（快捷方式） cp -s a.txt link_a.txt ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:7","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"9、cat 命令 cat 主要有三大功能： 1.一次显示整个文件: cat filename 2.从键盘创建一个文件: cat \u003e filename 只能创建新文件，不能编辑已有文件。 3.将几个文件合并为一个文件: cat file1 file2 \u003e file -b 对非空输出行号 -n 输出所有行号 实例： （1）把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里 cat -n log2012.log log2013.log （2）把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里 cat -b log2012.log log2013.log log.log （3）使用 here doc 生成新文件 cat \u003elog.txt \u003c\u003cEOF \u003eHello \u003eWorld \u003ePWD=$(pwd) \u003eEOF ls -l log.txt cat log.txt Hello World PWD=/opt/soft/test （4）反向列示 tac log.txt PWD=/opt/soft/test World Hello ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:8","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"10、more 命令 功能类似于 cat, more 会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示。 命令参数： +n 从笫 n 行开始显示 -n 定义屏幕大小为n行 +/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示 -d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能 -l 忽略Ctrl+l（换页）字符 -p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似 -s 把连续的多个空行显示为一行 -u 把文件内容中的下画线去掉 常用操作命令： Enter 向下 n 行，需要定义。默认为 1 行 Ctrl+F 向下滚动一屏 空格键 向下滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 :f 输出文件名和当前行的行号 V 调用vi编辑器 !命令 调用Shell，并执行命令 q 退出more 实例： （1）显示文件中从第3行起的内容 more +3 text.txt （2）在所列出文件目录详细信息，借助管道使每次显示 5 行 ls -l | more -5 按空格显示下 5 行。 ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:9","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"11、less 命令 less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。 常用命令参数： -i 忽略搜索时的大小写 -N 显示每行的行号 -o \u003c文件名\u003e 将less 输出的内容在指定文件中保存起来 -s 显示连续空行为一行 /字符串：向下搜索“字符串”的功能 ?字符串：向上搜索“字符串”的功能 n：重复前一个搜索（与 / 或 ? 有关） N：反向重复前一个搜索（与 / 或 ? 有关） -x \u003c数字\u003e 将“tab”键显示为规定的数字空格 b 向后翻一页 d 向后翻半页 h 显示帮助界面 Q 退出less 命令 u 向前滚动半页 y 向前滚动一行 空格键 滚动一行 回车键 滚动一页 [pagedown]： 向下翻动一页 [pageup]： 向上翻动一页 实例： （1）ps 查看进程信息并通过 less 分页显示 ps -aux | less -N （2）查看多个文件 less 1.log 2.log 可以使用 n 查看下一个，使用 p 查看前一个。 ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:10","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"12、head 命令 head 用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行。 常用参数： -n\u003c行数\u003e 显示的行数（行数为复数表示从最后向前数） 实例： （1）显示 1.log 文件中前 20 行 head 1.log -n 20 （2）显示 1.log 文件前 20 字节 head -c 20 log2014.log （3）显示 t.log最后 10 行 head -n -10 t.log ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:11","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"13、tail 命令 用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。 常用参数： -f 循环读取（常用于查看递增的日志文件） -n\u003c行数\u003e 显示行数（从后向前） （1）循环读取逐渐增加的文件内容 ping 127.0.0.1 \u003e ping.log \u0026 后台运行：可使用 jobs -l 查看，也可使用 fg 将其移到前台运行。 tail -f ping.log （查看日志） ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:12","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"14、which 命令 在 linux 要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索： which 查看可执行文件的位置。 whereis 查看文件的位置。 locate 配合数据库查看文件位置。 find 实际搜寻硬盘查询文件名称。 which 是在 PATH 就是指定的路径中，搜索某个系统命令的位置，并返回第一个搜索结果。使用 which 命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 常用参数： -n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。 实例： （1）查看 ls 命令是否存在，执行哪个 which ls （2）查看 which which which （3）查看 cd which cd（显示不存在，因为 cd 是内建命令，而 which 查找显示是 PATH 中的命令） 查看当前 PATH 配置： echo $PATH 或使用 env 查看所有环境变量及对应值 ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:13","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"15、whereis 命令 whereis 命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。whereis 及 locate 都是基于系统内建的数据库进行搜索，因此效率很高，而find则是遍历硬盘查找文件。 常用参数： -b 定位可执行文件。 -m 定位帮助文件。 -s 定位源代码文件。 -u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。 实例： （1）查找 locate 程序相关文件 whereis locate （2）查找 locate 的源码文件 whereis -s locate （3）查找 lcoate 的帮助文件 whereis -m locate ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:14","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"16、locate 命令 locate 通过搜寻系统内建文档数据库达到快速找到档案，数据库由 updatedb 程序来更新，updatedb 是由 cron daemon 周期性调用的。默认情况下 locate 命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是 locate 所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb 每天会跑一次，可以由修改 crontab 来更新设定值 (etc/crontab)。 locate 与 find 命令相似，可以使用如 *、? 等进行正则匹配查找 常用参数： -l num（要显示的行数） -f 将特定的档案系统排除在外，如将proc排除在外 -r 使用正则运算式做为寻找条件 实例： （1）查找和 pwd 相关的所有文件(文件名中包含 pwd） locate pwd （2）搜索 etc 目录下所有以 sh 开头的文件 locate /etc/sh （3）查找 /var 目录下，以 reason 结尾的文件 locate -r '^/var.*reason$'（其中.表示一个字符，*表示任务多个；.*表示任意多个字符） ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:15","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"17、find 命令 用于在文件树中查找文件，并作出相应的处理。 命令格式： find pathname -options [-print -exec -ok ...] 命令参数： pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。 -print： find命令将匹配的文件输出到标准输出。 -exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为'command' { } \\;，注意{ }和\\；之间的空格。 -ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。 命令选项： -name 按照文件名查找文件 -perm 按文件权限查找文件 -user 按文件属主查找文件 -group 按照文件所属的组来查找文件。 -type 查找某一类型的文件，诸如： b - 块设备文件 d - 目录 c - 字符设备文件 l - 符号链接文件 p - 管道文件 f - 普通文件 -size n :[c] 查找文件长度为n块文件，带有c时表文件字节大小 -amin n 查找系统中最后N分钟访问的文件 -atime n 查找系统中最后n*24小时访问的文件 -cmin n 查找系统中最后N分钟被改变文件状态的文件 -ctime n 查找系统中最后n*24小时被改变文件状态的文件 -mmin n 查找系统中最后N分钟被改变文件数据的文件 -mtime n 查找系统中最后n*24小时被改变文件数据的文件 (用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。 ) -maxdepth n 最大查找目录深度 -prune 选项来指出需要忽略的目录。在使用-prune选项时要当心，因为如果你同时使用了-depth选项，那么-prune选项就会被find命令忽略 -newer 如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用-newer选项 实例： （1）查找 48 小时内修改过的文件 find -atime -2 （2）在当前目录查找 以 .log 结尾的文件。 . 代表当前目录 find ./ -name '*.log' （3）查找 /opt 目录下 权限为 777 的文件 find /opt -perm 777 （4）查找大于 1K 的文件 find -size +1000c 查找等于 1000 字符的文件 find -size 1000c -exec 参数后面跟的是 command 命令，它的终止是以 ; 为结束标志的，所以这句命令后面的分号是不可缺少的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。{} 花括号代表前面find查找出来的文件名。 实例： （5）在当前目录中查找更改时间在10日以前的文件并删除它们(无提醒） find . -type f -mtime +10 -exec rm -f {} \\; （6）当前目录中查找所有文件名以.log结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示。 按y键删除文件，按n键不删除 find . -name '*.log' mtime +5 -ok -exec rm {} \\; （7）当前目录下查找文件名以 passwd 开头，内容包含 “pkg” 字符的文件 find . -f -name 'passwd*' -exec grep \"pkg\" {} \\; （8）用 exec 选项执行 cp 命令 find . -name '*.log' -exec cp {} test3 \\; -xargs find 命令把匹配到的文件传递给 xargs 命令，而 xargs 命令每次只获取一部分文件而不是全部，不像 -exec 选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。 实例： （9）查找当前目录下每个普通文件，然后使用 xargs 来判断文件类型 find . -type f -print | xargs file （10）查找当前目录下所有以 js 结尾的并且其中包含 ‘editor’ 字符的普通文件 find . -type f -name \"*.js\" -exec grep -lF 'ueditor' {} \\; find -type f -name '*.js' | xargs grep -lF 'editor' （11）利用 xargs 执行 mv 命令 find . -name \"*.log\" | xargs -i mv {} test4 （12）用 grep 命令在当前目录下的所有普通文件中搜索 hostnames 这个词，并标出所在行： find . -name \\*(转义） -type f -print | xargs grep -n 'hostnames' （13）查找当前目录中以一个小写字母开头，最后是 4 到 9 加上 .log 结束的文件： find . -name '[a-z]*[4-9].log' -print （14）在 test 目录查找不在 test4 子目录查找 find test -path 'test/test4' -prune -o -print （15）实例1：查找更改时间比文件 log2012.log新但比文件 log2017.log 旧的文件 find -newer log2012.log ! -newer log2017.log 使用 depth 选项： depth 选项可以使 find 命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件。 实例：find 命令从文件系统的根目录开始，查找一个名为 CON.FILE 的文件。 它将首先匹配所有的文件然后再进入子目录中查找 find / -name \"CON.FILE\" -depth -print ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:16","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"18、chmod 命令 用于改变 linux 系统文件或目录的访问权限。用它控制文件或目录的访问权限。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。 每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。可使用 ls -l test.txt 查找。 以文件 log2012.log 为例： -rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log 第一列共有 10 个位置，第一个字符指定了文件类型。在通常意义上，一个目录也是一个文件。如果第一个字符是横线，表示是一个非目录的文件。如果是 d，表示是一个目录。从第二个字符开始到第十个 9 个字符，3 个字符一组，分别表示了 3 组用户对文件或者目录的权限。权限字符用横线代表空许可，r 代表只读，w 代表写，x 代表可执行。 常用参数： -c 当发生改变时，报告处理信息 -R 处理指定目录以及其子目录下所有文件 权限范围： u ：目录或者文件的当前的用户 g ：目录或者文件的当前的群组 o ：除了目录或者文件的当前用户或群组之外的用户或者群组 a ：所有的用户及群组 权限代号： r ：读权限，用数字4表示 w ：写权限，用数字2表示 x ：执行权限，用数字1表示 - ：删除权限，用数字0表示 s ：特殊权限 实例： （1）增加文件 t.log 所有用户可执行权限 chmod a+x t.log （2）撤销原来所有的权限，然后使拥有者具有可读权限,并输出处理信息 chmod u=r t.log -c （3）给 file 的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限 chmod 751 t.log -c（或者：chmod u=rwx,g=rx,o=x t.log -c) （4）将 test 目录及其子目录所有文件添加可读权限 chmod u+r,g+r,o+r -R text/ -c 19、tar 命令 用来压缩和解压文件。tar 本身不具有压缩功能，只具有打包功能，有关压缩及解压是调用其它的功能来完成。 弄清两个概念：打包和压缩。打包是指将一大堆文件或目录变成一个总的文件；压缩则是将一个大的文件通过一些压缩算法变成一个小文件 常用参数： -c 建立新的压缩文件 -f 指定压缩文件 -r 添加文件到已经压缩文件包中 -u 添加改了和现有的文件到压缩包中 -x 从压缩包中抽取文件 -t 显示压缩文件中的内容 -z 支持gzip压缩 -j 支持bzip2压缩 -Z 支持compress解压文件 -v 显示操作过程 有关 gzip 及 bzip2 压缩: gzip 实例：压缩 gzip fileName .tar.gz 和.tgz 解压：gunzip filename.gz 或 gzip -d filename.gz 对应：tar zcvf filename.tar.gz tar zxvf filename.tar.gz bz2实例：压缩 bzip2 -z filename .tar.bz2 解压：bunzip filename.bz2或bzip -d filename.bz2 对应：tar jcvf filename.tar.gz 解压：tar jxvf filename.tar.bz2 实例： （1）将文件全部打包成 tar 包 tar -cvf log.tar 1.log,2.log 或tar -cvf log.* （2）将 /etc 下的所有文件及目录打包到指定目录，并使用 gz 压缩 tar -zcvf /tmp/etc.tar.gz /etc （3）查看刚打包的文件内容（一定加z，因为是使用 gzip 压缩的） tar -ztvf /tmp/etc.tar.gz （4）要压缩打包 /home, /etc ，但不要 /home/dmtsai tar --exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:17","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"20、chown 命令 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户 ID；组可以是组名或者组 ID；文件是以空格分开的要改变权限的文件列表，支持通配符。 -c 显示更改的部分的信息 -R 处理指定目录及子目录 实例： （1）改变拥有者和群组 并显示改变信息 chown -c mail:mail log2012.log （2）改变文件群组 chown -c :mail t.log （3）改变文件夹及子文件目录属主及属组为 mail chown -cR mail: test/ ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:18","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"21、df 命令 显示磁盘空间使用情况。获取硬盘被占用了多少空间，目前还剩下多少空间等信息，如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以 1KB 为单位进行显示，除非环境变量 POSIXLY_CORRECT 被指定，那样将以512字节为单位进行显示： -a 全部文件系统列表 -h 以方便阅读的方式显示信息 -i 显示inode信息 -k 区块为1024字节 -l 只显示本地磁盘 -T 列出文件系统类型 实例： （1）显示磁盘使用情况 df -l （2）以易读方式列出所有文件系统及其类型 df -haT ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:19","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"22、du 命令 du 命令也是查看使用空间的，但是与 df 命令不同的是 Linux du 命令是对文件和目录磁盘使用的空间的查看： 命令格式： du [选项] [文件] 常用参数： -a 显示目录中所有文件大小 -k 以KB为单位显示文件大小 -m 以MB为单位显示文件大小 -g 以GB为单位显示文件大小 -h 以易读方式显示文件大小 -s 仅显示总计 -c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和 实例： （1）以易读方式显示文件夹内及子文件夹大小 du -h scf/ （2）以易读方式显示文件夹内所有文件大小 du -ah scf/ （3）显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和 du -hc test/ scf/ （4）输出当前目录下各个子目录所使用的空间 du -hc --max-depth=1 scf/ ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:20","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"23、ln 命令 功能是为文件在另外一个位置建立一个同步的链接，当在不同目录需要该问题时，就不需要为每一个目录创建同样的文件，通过 ln 创建的链接（link）减少磁盘占用量。 链接分类：软件链接及硬链接 软链接： 1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式 2.软链接可以 跨文件系统 ，硬链接不可以 3.软链接可以对一个不存在的文件名进行链接 4.软链接可以对目录进行链接 硬链接: 1.硬链接，以文件副本的形式存在。但不占用实际空间。 2.不允许给目录创建硬链接 3.硬链接只有在同一个文件系统中才能创建 需要注意： 第一：ln命令会保持每一处链接文件的同步性，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化； 第二：ln的链接又分软链接和硬链接两种，软链接就是ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。 第三：ln指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。 常用参数： -b 删除，覆盖以前建立的链接 -s 软链接（符号链接） -v 显示详细处理过程 实例： （1）给文件创建软链接，并显示操作信息 ln -sv source.log link.log （2）给文件创建硬链接，并显示操作信息 ln -v source.log link1.log （3）给目录创建软链接 ln -sv /opt/soft/test/test3 /opt/soft/test/test5 ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:21","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"24、date 命令 显示或设定系统的日期与时间。 命令参数： -d\u003c字符串\u003e 显示字符串所指的日期与时间。字符串前后必须加上双引号。 -s\u003c字符串\u003e 根据字符串来设置日期与时间。字符串前后必须加上双引号。 -u 显示GMT。 %H 小时(00-23) %I 小时(00-12) %M 分钟(以00-59来表示) %s 总秒数。起算时间为1970-01-01 00:00:00 UTC。 %S 秒(以本地的惯用法来表示) %a 星期的缩写。 %A 星期的完整名称。 %d 日期(以01-31来表示)。 %D 日期(含年月日)。 %m 月份(以01-12来表示)。 %y 年份(以00-99来表示)。 %Y 年份(以四位数来表示)。 实例： （1）显示下一天 date +%Y%m%d --date=\"+1 day\" //显示下一天的日期 （2）-d参数使用 date -d \"nov 22\" 今年的 11 月 22 日是星期三 date -d '2 weeks' 2周后的日期 date -d 'next monday' (下周一的日期) date -d next-day +%Y%m%d（明天的日期）或者：date -d tomorrow +%Y%m%d date -d last-day +%Y%m%d(昨天的日期) 或者：date -d yesterday +%Y%m%d date -d last-month +%Y%m(上个月是几月) date -d next-month +%Y%m(下个月是几月) ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:22","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"25、cal 命令 可以用户显示公历（阳历）日历如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份： 常用参数： -3 显示前一月，当前月，后一月三个月的日历 -m 显示星期一为第一列 -j 显示在当前年第几天 -y [year]显示当前年[year]份的日历 实例： （1）显示指定年月日期 cal 9 2012 （2）显示2013年每个月日历 cal -y 2013 （3）将星期一做为第一列,显示前中后三月 cal -3m ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:23","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"26、grep 命令 强大的文本搜索命令，grep(Global Regular Expression Print) 全局正则表达式搜索。 grep 的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。 命令格式： grep [option] pattern file|dir 常用参数： -A n --after-context显示匹配字符后n行 -B n --before-context显示匹配字符前n行 -C n --context 显示匹配字符前后n行 -c --count 计算符合样式的列数 -i 忽略大小写 -l 只列出文件内容符合指定的样式的文件名称 -f 从文件中读取关键词 -n 显示匹配内容的所在文件中行数 -R 递归查找文件夹 grep 的规则表达式: ^ #锚定行的开始 如：'^grep'匹配所有以grep开头的行。 $ #锚定行的结束 如：'grep$'匹配所有以grep结尾的行。 . #匹配一个非换行符的字符 如：'gr.p'匹配gr后接一个任意字符，然后是p。 * #匹配零个或多个先前字符 如：'*grep'匹配所有一个或多个空格后紧跟grep的行。 .* #一起用代表任意字符。 [] #匹配一个指定范围内的字符，如'[Gg]rep'匹配Grep和grep。 [^] #匹配一个不在指定范围内的字符，如：'[^A-FH-Z]rep'匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。 \\(..\\) #标记匹配字符，如'\\(love\\)'，love被标记为1。 \\\u003c #锚定单词的开始，如:'\\\u003cgrep'匹配包含以grep开头的单词的行。 \\\u003e #锚定单词的结束，如'grep\\\u003e'匹配包含以grep结尾的单词的行。 x\\{m\\} #重复字符x，m次，如：'0\\{5\\}'匹配包含5个o的行。 x\\{m,\\} #重复字符x,至少m次，如：'o\\{5,\\}'匹配至少有5个o的行。 x\\{m,n\\} #重复字符x，至少m次，不多于n次，如：'o\\{5,10\\}'匹配5--10个o的行。 \\w #匹配文字和数字字符，也就是[A-Za-z0-9]，如：'G\\w*p'匹配以G后跟零个或多个文字或数字字符，然后是p。 \\W #\\w的反置形式，匹配一个或多个非单词字符，如点号句号等。 \\b #单词锁定符，如: '\\bgrep\\b'只匹配grep。 实例： （1）查找指定进程 ps -ef | grep svn （2）查找指定进程个数 ps -ef | grep svn -c （3）从文件中读取关键词 cat test1.txt | grep -f key.log （4）从文件夹中递归查找以grep开头的行，并只列出文件 grep -lR '^grep' /tmp （5）查找非x开关的行内容 grep '^[^x]' test.txt （6）显示包含 ed 或者 at 字符的内容行 grep -E 'ed|at' test.txt ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:24","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"27、wc 命令 wc(word count)功能为统计指定的文件中字节数、字数、行数，并将统计结果输出 命令格式： wc [option] file.. 命令参数： -c 统计字节数 -l 统计行数 -m 统计字符数 -w 统计词数，一个字被定义为由空白、跳格或换行字符分隔的字符串 实例： （1）查找文件的 行数 单词数 字节数 文件名 wc text.txt 结果： 7 8 70 test.txt （2）统计输出结果的行数 cat test.txt | wc -l ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:25","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"28、ps 命令 ps(process status)，用来查看当前运行的进程状态，一次性查看，如果需要动态连续结果使用 top linux上进程有5种状态: \\1. 运行(正在运行或在运行队列中等待) \\2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) \\3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) \\4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) \\5. 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) ps 工具标识进程的5种状态码: D 不可中断 uninterruptible sleep (usually IO) R 运行 runnable (on run queue) S 中断 sleeping T 停止 traced or stopped Z 僵死 a defunct (”zombie”) process 命令参数： -A 显示所有进程 a 显示所有进程 -a 显示同一终端下所有进程 c 显示进程真实名称 e 显示环境变量 f 显示进程间的关系 r 显示当前终端运行的进程 -aux 显示所有包含其它使用的进程 实例： （1）显示当前所有进程环境变量及进程间关系 ps -ef （2）显示当前所有进程 ps -A （3）与grep联用查找某进程 ps -aux | grep apache （4）找出与 cron 与 syslog 这两个服务有关的 PID 号码 ps aux | grep '(cron|syslog)' 29、top 命令 显示当前系统正在执行的进程的相关信息，包括进程 ID、内存占用率、CPU 占用率等 常用参数： -c 显示完整的进程命令 -s 保密模式 -p \u003c进程号\u003e 指定进程显示 -n \u003c次数\u003e循环显示次数 实例： （1） top - 14:06:23 up 70 days, 16:44, 2 users, load average: 1.25, 1.32, 1.35 Tasks: 206 total, 1 running, 205 sleeping, 0 stopped, 0 zombie Cpu(s): 5.9%us, 3.4%sy, 0.0%ni, 90.4%id, 0.0%wa, 0.0%hi, 0.2%si, 0.0%st Mem: 32949016k total, 14411180k used, 18537836k free, 169884k buffers Swap: 32764556k total, 0k used, 32764556k free, 3612636k cached PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 28894 root 22 0 1501m 405m 10m S 52.2 1.3 2534:16 java 前五行是当前系统情况整体的统计信息区。 第一行，任务队列信息，同 uptime 命令的执行结果，具体参数说明情况如下： 14:06:23 — 当前系统时间 up 70 days, 16:44 — 系统已经运行了70天16小时44分钟（在这期间系统没有重启过的吆！） 2 users — 当前有2个用户登录系统 load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。 load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。 第二行，Tasks — 任务（进程），具体信息说明如下： 系统现在共有206个进程，其中处于运行中的有1个，205个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。 第三行，cpu状态信息，具体属性说明如下： 5.9%us — 用户空间占用CPU的百分比。 3.4% sy — 内核空间占用CPU的百分比。 0.0% ni — 改变过优先级的进程占用CPU的百分比 90.4% id — 空闲CPU百分比 0.0% wa — IO等待占用CPU的百分比 0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比 0.2% si — 软中断（Software Interrupts）占用CPU的百分比 **备注：**在这里CPU的使用比率和windows概念不同，需要理解linux系统用户空间和内核空间的相关知识！ 第四行，内存状态，具体信息如下： 32949016k total — 物理内存总量（32GB） 14411180k used — 使用中的内存总量（14GB） 18537836k free — 空闲内存总量（18GB） 169884k buffers — 缓存的内存量 （169M） 第五行，swap交换分区信息，具体信息说明如下： 32764556k total — 交换区总量（32GB） 0k used — 使用的交换区总量（0K） 32764556k free — 空闲交换区总量（32GB） 3612636k cached — 缓冲的交换区总量（3.6GB） 第六行，空行。 第七行以下：各进程（任务）的状态监控，项目列信息说明如下： PID — 进程id USER — 进程所有者 PR — 进程优先级 NI — nice值。负值表示高优先级，正值表示低优先级 VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA SHR — 共享内存大小，单位kb S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程 %CPU — 上次更新到现在的CPU时间占用百分比 %MEM — 进程使用的物理内存百分比 TIME+ — 进程使用的CPU时间总计，单位1/100秒 COMMAND — 进程名称（命令名/命令行） top 交互命令 h 显示top交互命令帮助信息 c 切换显示命令名称和完整命令行 m 以内存使用率排序 P 根据CPU使用百分比大小进行排序 T 根据时间/累计时间进行排序 W 将当前设置写入~/.toprc文件中 o或者O 改变显示项目的顺序 ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:26","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"30、kill 命令 发送指定的信号到相应进程。不指定型号将发送SIGTERM（15）终止指定进程。如果任无法终止该程序可用\"-KILL\" 参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用ps命令或者jobs 命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。 常用参数： -l 信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称 -a 当处理当前进程时，不限制命令名和进程号的对应关系 -p 指定kill 命令只打印相关进程的进程号，而不发送任何信号 -s 指定发送信号 -u 指定用户 实例： （1）先使用ps查找进程pro1，然后用kill杀掉 kill -9 $(ps -ef | grep pro1) ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:27","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"31、free 命令 显示系统内存使用情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。 命令参数： -b 以Byte显示内存使用情况 -k 以kb为单位显示内存使用情况 -m 以mb为单位显示内存使用情况 -g 以gb为单位显示内存使用情况 -s\u003c间隔秒数\u003e 持续显示内存 -t 显示内存使用总合 实例： （1）显示内存使用情况 free free -k free -m （2）以总和的形式显示内存的使用信息 free -t （3）周期性查询内存使用情况 free -s 10 原文地址：https://www.cnblogs.com/gaojun/p/3359355.html ","date":"2020-07-12","objectID":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/:0:28","tags":["Linux"],"title":"Linux常用命令","uri":"/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"},{"categories":null,"content":"Java基础-常见概念 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:0:0","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"范型 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:1:0","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"定义 把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:1:1","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"设计原则 只要在编译时期没有出现警告，那么运行时期就不会出现ClassCastException异常 参数化类型 把类型当作是参数一样传递 \u003c数据类型\u003e 只能是引用类型 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:1:2","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"为什么需要 早期Java是使用Object来代表任意类型的，但是向下转型有强转的问题，这样程序就不太安全 带来的好处 代码更加简洁【不用强制转换】 程序更加健壮【只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常】 可读性和稳定性【在编写集合的时候，就限定了类型】 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:1:3","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"类型擦除 将范型Java代码转化为普通代卖，在编译器编译过程中 将所有泛型参数使用其最左边界（最顶级父类）类型替换。 移除所有的类型参数 带来的问题 重载 编译不通过 catch 匹配多种类型 静态变量 泛型类所有实例关联到同一字节码，静态变量共享 参考：https://segmentfault.com/a/1190000014120746 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:1:4","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"equals 和 == ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:2:0","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"使用 基本类型 只能使用== 对象 都比较地址 其它（包装类） “==“除了比较基本数据之外都是比较的内存地址 “equals\"除了没有没有重写equals方法的类之外都是比较的内容 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:2:1","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"hashcode、equals 两个对象用equals()比较返回true，那么两个对象的hashCode()方法必须返回相同的结果。 两个对象用equals()比较返回false，不要求hashCode()方法也一定返回不同的值，但是最好返回不同值，亿提搞哈希表性能。 重写equals()方法，必须重写hashCode()方法，以保证equals方法相等时两个对象hashcode返回相同的值。 hash算法 https://blog.csdn.net/l1028386804/article/details/54573106 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:3:0","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"自动装箱 装箱：基本类型转变为包装器类型的过程。Integer.valueOf() 拆箱：包装器类型转变为基本类型的过程。intValue 自动装箱 每当需要一种类型的对象时，这种基本类型就自动地封装到与它相同类型的包装中。例：Integer a = 10; 自动拆箱 每当需要一个值时，被装箱对象中的值就被自动地提取出来，没必要再去调用intValue()和doubleValue()方法。例：int a = new Integer(10) ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:4:0","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"引用 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:5:0","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"强引用 直接将对象赋值给变量 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:5:1","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"软引用 SoftReference 如果一个对象只具有软引用，则内存空间充足时，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:5:2","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"软引用 WeakReference 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期 一旦GC，不管当前内存空间足够与否，都会回收它的内存 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:5:3","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"虚引用 PhantomReference 虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收 虚引用主要用来跟踪对象被垃圾回收器回收的活动。 虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:5:4","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"String，StringBuffer，StringBuilder ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:6:0","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"String 字符串常量 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:6:1","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"StringBuffer 字符串变量 线程安全 速度慢 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:6:2","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"StringBuilder 字符串变量 非线程安全 速度快 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:6:3","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"异常分类 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:7:0","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"Throwable Error Exception RuntimeException java.lang.NullPointerException\u003c空指针异常\u003e java.lang.IndexOutOfBoundsException\u003c 索引超出范围\u003e java.lang.ArrayIndexOutOfBoundsException\u003c数组索引越界\u003e java.lang.NumberFormatException\u003c转换为数值类型异常\u003e java.lang.ClassCastException \u003c类型转换异常\u003e java.lang.ArithmeticException \u003c算数异常\u003e 一般异常(检查异常) java.lang.ClassNotFoundException\u003c类未找到异常\u003e java.io.IOException\u003cIO异常\u003e ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:7:1","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"异常处理 throw :一定会抛出该异常，通常出现在方法内部用于显式抛出 throws :抛出有可能出现的异常，出现在方法声明区域（在参数列表后面） try ：try语句块一般用于将有可能出现异常的语句包裹 catch：处理try语句块中可能出现的异常，一旦异常产生则进入对应的catch块(可以catch多种异常) finally：finally语句块中内容无论是否出现异常，都会执行，一般用执行资源清理与回收 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:7:2","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"重载、重写 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:8:0","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"重载 方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。 重载Overloading是一个类中多态性的一种表现。 Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。 调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。 父类方法被默认修饰时，只能在同一包中，被其子类被重写，如果不在同一包则不能重写。 父类的方法被protoeted时，不仅在同一包中，被其子类被重写，还可以不同包的子类重写。 重载的规则： 必须具有不同的参数列表； 可以有不同的返回类型，只要参数列表不同就可以了； 可以有不同的访问修饰符； 可以抛出不同的异常； 特点 在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int, float)， 但是不能为fun(int, int)）； 不能通过访问权限、返回类型、抛出的异常进行重载； 方法的异常类型和数目不会对重载造成影响； 对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:8:1","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"重写 规则 参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。 返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。 访问修饰符的限制一定要大于被重写方法的访问修饰符（public\u003eprotected\u003edefault\u003eprivate） 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:8:2","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"总结 overload（重载） 参数类型、个数、顺序至少有一个不相同。 不能重载只有返回值不同的方法名。 存在于父类和子类、同类中。 override（重写） 方法名、参数、返回值相同。 子类方法不能缩小父类方法的访问权限。 子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。 存在于父类和子类之间。 方法被定义为final不能被重写。 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:8:3","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"抽象类、接口 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:9:0","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"方法实现 抽象类 它可以有默认的方法实现 抽象类可以没有抽象方法，有抽象方法必须是抽象类 抽象方法不能被实现，只能放入子类实现 子类是抽象类，可以不实现父类抽象类，否则，必须实现父类抽象类 接口 接口完全是抽象的。它根本不存在方法的实现 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:9:1","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"实现 抽象类 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。 接口 子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:9:2","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"构造器 抽象类 抽象类可以有构造器。子类可以调用，主要用于成员变量的赋值 接口 接口不能有构造器 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:9:3","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"与正常类区别 抽象类 除了你不能实例化抽象类之外，它和普通Java类没有任何区别 接口 接口是完全不同的类型 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:9:4","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"访问修饰符 抽象类 抽象方法可以有main方法并且我们可以运行它 接口 接口没有main方法，因此我们不能运行它。 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:9:5","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"多继承 抽象类 抽象方法可以继承一个类和实现多个接口 接口 接口只可以继承一个或多个其它接口 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:9:6","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"添加新方法 抽象类 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。 接口 如果你往接口中添加方法，那么你必须改变实现该接口的类 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:9:7","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"使用场景 如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。 如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。 如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:9:8","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"反射 对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 请看这篇文章：Java反射机制 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:10:0","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"序列化与反序列化 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:11:0","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"序列化 为什么需要序列化 类的对象会随着程序的终止而被垃圾收集器销毁。如果要在不重新创建对象的情况下调用该类，该怎么做？这就可以通过序列化将数据转换为字节流。 定义 将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象— 过程 1、在Java中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化。 2、通过ObjectOutputStream和ObjectInputStream对对象进行序列化及反序列化 3、虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID） 4、序列化并不保存静态变量。 5、要想将父类对象也序列化，就需要让父类也实现Serializable 接口。 6、Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。 7、服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。 Transient 控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值 序列化ID 虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致 生成策略 固定的 1L 随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具生成） ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:11:1","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"BIO、NIO ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:12:0","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"BIO 同步阻塞I/O 服务端会调用accept方法等待接收客户端的连接请求，一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:12:1","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"NIO 同步非阻[塞I/O 若服务端监听到客户端连接请求，便为其建立通信套接字(java中就是通道)，然后返回继续监听，若同时有多个客户端连接请求到来也可以全部收到，依次为它们都建立通信套接字。 若服务端监听到来自已经创建了通信套接字的客户端发送来的数据，就会调用对应接口处理接收到的数据，若同时有多个客户端发来数据也可以依次进行处理。 监听多个客户端的连接请求和接收数据请求同时还能监听自己时候有数据要发送。 ","date":"2020-07-10","objectID":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/:12:2","tags":["Java基础"],"title":"Java基础概念","uri":"/java%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"},{"categories":null,"content":"  LoveIt is a clean, elegant but advanced blog theme for Hugo developed by Dillon. It is based on the original LeaveIt Theme and KeepIt Theme. Hugo Theme LoveItHugo Theme LoveIt \"\rHugo Theme LoveIt\r ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About LoveIt","uri":"/about/"},{"categories":null,"content":"Features Performance and SEO  Optimized for performance: 99/100 on mobile and 100/100 on desktop in Google PageSpeed Insights  Optimized SEO performance with a correct SEO SCHEMA based on JSON-LD  Google Analytics supported  Fathom Analytics supported  Search engine verification supported (Google, Bind, Yandex and Baidu)  CDN for third-party libraries supported  Automatically converted images with Lazy Load by lazysizes Appearance and Layout / Responsive layout / Light/Dark mode  Globally consistent design language  Pagination supported  Easy-to-use and self-expanding table of contents  Multilanguage supported and i18n ready  Beautiful CSS animation Social and Comment Systems  Gravatar supported by Gravatar  Local Avatar supported  Up to 64 social links supported  Up to 28 share sites supported  Disqus comment system supported by Disqus  Gitalk comment system supported by Gitalk  Valine comment system supported by Valine  Facebook comments system supported by Facebook  Telegram comments system supported by Comments  Commento comment system supported by Commento  Utterances comment system supported by Utterances Extended Features  Search supported by Lunr.js or algolia  Twemoji supported  Automatically highlighting code  Copy code to clipboard with one click  Images gallery supported by lightgallery.js  Extended Markdown syntax for Font Awesome icons  Extended Markdown syntax for ruby annotation  Extended Markdown syntax for fraction  Mathematical formula supported by $ \\KaTeX $  Diagrams shortcode supported by mermaid  Interactive data visualization shortcode supported by ECharts  Mapbox shortcode supported by Mapbox GL JS  Music player shortcode supported by APlayer and MetingJS  Bilibili player shortcode  Kinds of admonitions shortcode  Custom style shortcode  Custom script shortcode  Animated typing supported by TypeIt  Dynamic scroll supported by Smooth Scroll  Cookie consent banner supported by cookieconsent … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"About LoveIt","uri":"/about/"},{"categories":null,"content":"License LoveIt is licensed under the MIT license. Check the LICENSE file for details. Thanks to the authors of following resources included in the theme: normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"About LoveIt","uri":"/about/"}]