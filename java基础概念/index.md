# Java基础概念


# Java基础-常见概念

## 范型

### 定义

- 把类型明确的工作推迟到创建对象或调用方法的时候才去明确的特殊的类型

### 设计原则

- 只要在编译时期没有出现警告，那么运行时期就不会出现ClassCastException异常

- 参数化类型

	- 把类型当作是参数一样传递
	- <数据类型> 只能是引用类型

### 为什么需要

- 早期Java是使用Object来代表任意类型的，但是向下转型有强转的问题，这样程序就不太安全
- 带来的好处

  - 代码更加简洁【不用强制转换】
  - 程序更加健壮【只要编译时期没有警告，那么运行时期就不会出现ClassCastException异常】
  - 可读性和稳定性【在编写集合的时候，就限定了类型】

### 类型擦除

- 将范型Java代码转化为普通代卖，在编译器编译过程中
- 将所有泛型参数使用其最左边界（最顶级父类）类型替换。
- 移除所有的类型参数
- 带来的问题
  - 重载

  	- 编译不通过

  - catch

  	- 匹配多种类型

  - 静态变量

  	- 泛型类所有实例关联到同一字节码，静态变量共享
- 参考：https://segmentfault.com/a/1190000014120746

## equals 和 ==

### 使用

- 基本类型

  只能使用== 

- 对象

  都比较地址

- 其它（包装类）

  - "=="除了比较基本数据之外都是比较的内存地址
  - "equals"除了没有没有重写equals方法的类之外都是比较的内容

## hashcode、equals

- 两个对象用equals()比较返回true，那么两个对象的hashCode()方法必须返回相同的结果。
- 两个对象用equals()比较返回false，不要求hashCode()方法也一定返回不同的值，但是最好返回不同值，亿提搞哈希表性能。
- 重写equals()方法，必须重写hashCode()方法，以保证equals方法相等时两个对象hashcode返回相同的值。

- hash算法

	- https://blog.csdn.net/l1028386804/article/details/54573106

## 自动装箱

- 装箱：基本类型转变为包装器类型的过程。Integer.valueOf()
- 拆箱：包装器类型转变为基本类型的过程。intValue
- 自动装箱

	- 每当需要一种类型的对象时，这种基本类型就自动地封装到与它相同类型的包装中。例：Integer a = 10;

- 自动拆箱

	- 每当需要一个值时，被装箱对象中的值就被自动地提取出来，没必要再去调用intValue()和doubleValue()方法。例：int a = new Integer(10)

## 引用

### 强引用

- 直接将对象赋值给变量

### 软引用 SoftReference

- 如果一个对象只具有软引用，则内存空间充足时，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些对象的内存

### 软引用 WeakReference

- 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期
- 一旦GC，不管当前内存空间足够与否，都会回收它的内存

### 虚引用 PhantomReference

- 虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收
- 虚引用主要用来跟踪对象被垃圾回收器回收的活动。
- 虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列(ReferenceQueue)联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

## String，StringBuffer，StringBuilder

### String

- 字符串常量
- String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象

### StringBuffer

- 字符串变量
- 线程安全
- 速度慢

### StringBuilder

- 字符串变量
- 非线程安全
- 速度快

## 异常分类

### Throwable

- #### Error
- #### Exception

	- ##### RuntimeException

		- java.lang.NullPointerException<空指针异常>
		- java.lang.IndexOutOfBoundsException< 索引超出范围>
		- java.lang.ArrayIndexOutOfBoundsException<数组索引越界>
		- java.lang.NumberFormatException<转换为数值类型异常>
		- java.lang.ClassCastException <类型转换异常>
		- java.lang.ArithmeticException <算数异常>

	- ##### 一般异常(检查异常)

		- java.lang.ClassNotFoundException<类未找到异常>
		- java.io.IOException<IO异常>

- ### 异常处理

	- throw :一定会抛出该异常，通常出现在方法内部用于显式抛出
	- throws :抛出有可能出现的异常，出现在方法声明区域（在参数列表后面）
	- try ：try语句块一般用于将有可能出现异常的语句包裹
	- catch：处理try语句块中可能出现的异常，一旦异常产生则进入对应的catch块(可以catch多种异常)
	- finally：finally语句块中内容无论是否出现异常，都会执行，一般用执行资源清理与回收

## 重载、重写

### 重载

**方法重载是让类以统一的方式处理不同类型数据的一种手段。多个同名函数同时存在，具有不同的参数个数/类型。**

重载Overloading是一个类中多态性的一种表现。

 Java的方法重载，就是在类中可以创建多个方法，它们具有相同的名字，但具有不同的参数和不同的定义。

调用方法时通过传递给它们的不同参数个数和参数类型来决定具体使用哪个方法, 这就是多态性。

 重载的时候，方法名要一样，但是参数类型和个数不一样，返回值类型可以相同也可以不相同。无法以返回型别作为重载函数的区分标准。

父类方法被默认修饰时，只能在同一包中，被其子类被重写，如果不在同一包则不能重写。

父类的方法被protoeted时，不仅在同一包中，被其子类被重写，还可以不同包的子类重写。

**重载的规则：**

- 必须具有不同的参数列表；
- 可以有不同的返回类型，只要参数列表不同就可以了；
- 可以有不同的访问修饰符；
- 可以抛出不同的异常；

**特点**

- 在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int, float)， 但是不能为fun(int, int)）；

- 不能通过访问权限、返回类型、抛出的异常进行重载；

- 方法的异常类型和数目不会对重载造成影响；

- 对于继承来说，如果某一方法在父类中是访问权限是priavte，那么就不能在子类对其进行重载，如果定义的话，也只是定义了一个新方法，而不会达到重载的效果。

### **重写**

**规则**

- 参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。
- 返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。
- 访问修饰符的限制一定要大于被重写方法的访问修饰符（public>protected>default>private）
- 重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。

### 总结

#### overload（重载）

- 参数类型、个数、顺序至少有一个不相同。
- 不能重载只有返回值不同的方法名。
- 存在于父类和子类、同类中。

#### override（重写）

- 方法名、参数、返回值相同。
- 子类方法不能缩小父类方法的访问权限。
- 子类方法不能抛出比父类方法更多的异常(但子类方法可以不抛出异常)。
- 存在于父类和子类之间。
- 方法被定义为final不能被重写。
  

## 抽象类、接口

### 方法实现

- **抽象类**
- 它可以有默认的方法实现
	- 抽象类可以没有抽象方法，有抽象方法必须是抽象类
	- 抽象方法不能被实现，只能放入子类实现
	- 子类是抽象类，可以不实现父类抽象类，否则，必须实现父类抽象类
	
- **接口**
- 接口完全是抽象的。它根本不存在方法的实现

### 实现

- **抽象类**
- 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。
	
- **接口**
- 子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现

### 构造器

- **抽象类**
- 抽象类可以有构造器。子类可以调用，主要用于成员变量的赋值
	
- **接口**
- 接口不能有构造器

### 与正常类区别

- **抽象类**
- 除了你不能实例化抽象类之外，它和普通Java类没有任何区别
	
- **接口**
- 接口是完全不同的类型

### 访问修饰符

- **抽象类**
- 抽象方法可以有main方法并且我们可以运行它
	
- **接口**
- 接口没有main方法，因此我们不能运行它。

### 多继承

- **抽象类**
- 抽象方法可以继承一个类和实现多个接口
	
- **接口**
- 接口只可以继承一个或多个其它接口

### 添加新方法

- **抽象类**
- 如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。
	
- **接口**
- 如果你往接口中添加方法，那么你必须改变实现该接口的类

### 使用场景

- 如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。
- 如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。
- 如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。

## 反射

对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。

请看这篇文章：[Java反射机制](https://lei-zz.github.io/2020/07/13/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6.html)

## 序列化与反序列化

### 序列化

#### 为什么需要序列化

类的对象会随着程序的终止而被垃圾收集器销毁。如果要在不重新创建对象的情况下调用该类，该怎么做？这就可以通过序列化将数据转换为字节流。

#### 定义

将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象—

#### 过程

- 1、在Java中，只要一个类实现了java.io.Serializable接口，那么它就可以被序列化。
- 2、通过ObjectOutputStream和ObjectInputStream对对象进行序列化及反序列化
- 3、虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致（就是 private static final long serialVersionUID）
- 4、序列化并不保存静态变量。
- 5、要想将父类对象也序列化，就需要让父类也实现Serializable 接口。
- 6、Transient 关键字的作用是控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值，如 int 型的是 0，对象型的是 null。
- 7、服务器端给客户端发送序列化对象数据，对象中有一些数据是敏感的，比如密码字符串等，希望对该密码字段在序列化时，进行加密，而客户端如果拥有解密的密钥，只有在客户端进行反序列化时，才可以对密码进行读取，这样可以一定程度保证序列化对象的数据安全。

#### Transient

控制变量的序列化，在变量声明前加上该关键字，可以阻止该变量被序列化到文件中，在被反序列化后，transient 变量的值被设为初始值

#### 序列化ID

- 虚拟机是否允许反序列化，不仅取决于类路径和功能代码是否一致，一个非常重要的一点是两个类的序列化 ID 是否一致
- 生成策略

	- 固定的 1L
	- 随机生成一个不重复的 long 类型数据（实际上是使用 JDK 工具生成）

## BIO、NIO

### BIO  同步阻塞I/O

服务端会调用accept方法等待接收客户端的连接请求，一旦接收到一个连接请求，就可以建立通信套接字在这个通信套接字上进行读写操作，此时不能再接收其他客户端连接请求，只能等待同当前连接的客户端的操作执行完成

### NIO 同步非阻[塞I/O

- 若服务端监听到客户端连接请求，便为其建立通信套接字(java中就是通道)，然后返回继续监听，若同时有多个客户端连接请求到来也可以全部收到，依次为它们都建立通信套接字。 
-  若服务端监听到来自已经创建了通信套接字的客户端发送来的数据，就会调用对应接口处理接收到的数据，若同时有多个客户端发来数据也可以依次进行处理。 
-  监听多个客户端的连接请求和接收数据请求同时还能监听自己时候有数据要发送。 
