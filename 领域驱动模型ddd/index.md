# 领域驱动模型DDD


# 领域驱动模型DDD

## 定义

在开发前，通常需要进行大量的业务知识梳理，而后到达软件设计的层面，最后才是开发。而在业务知识梳理的过程中，我们必然会形成某个领域知识，根据领域知识来一步步驱动软件设计，就是领域驱动设计的基本概念。而领域驱动设计的核心就在于建立正确的领域驱动模型。

## 设计思想

业务逻辑不再集中在几个大型的类上，而是由大量相对小的领域对象(类)组成，这些类具备自己的状态和行为，每个类是相对完整的独立体，并与现实领域的业务对象映射。领域模型就是由这样许多的细粒度的类组成。

## 设计阶段

- 1、以一种领域专家、设计人员、开发人员都能理解的通用语言作为相互交流的工具，在交流的过程中发现领域概念，然后将这些概念设计成一个领域模型；
- 2、由领域模型驱动软件设计，用代码来实现该领域模型；

## 传统模型

- 对象是数据的载体，只有简单的getter/setter方法，没有行为。
- 以数据为中心，以数据库ER设计作驱动
- 贫血模式

  - 业务逻辑都是写在Service中的，WmActPoi充其量只是个数据载体，没有任何行为，是一种贫血模型
  - 业务逻辑复杂了，业务逻辑、状态会散落到在大量方法中，原本的代码意图会渐渐不明确，我们将这种情况称为由贫血症引起的失忆症

- 特点

  - a. 以数据库为中心
  - b. 贫血模型
  - c. 业务逻辑散落在大量的方法中
  - d. 当系统越来越复杂时，开发时间指数增长，维护成本很高

## 常见模型

-  DO(Data Object):此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。
-  DTO(Data Transfer Object):数据传输对象，Service 或 Manager 向外传输的对象。
-  BO(Business Object):业务对象，由 Service 层输出的封装业务逻辑的对象。
-  AO(ApplicationObject):应用对象，在Web层与Service层之间抽象的复用对象模型， 极为贴近展示层，复用度不高。
-  VO(View Object):显示层对象，通常是 Web 向模板渲染引擎层传输的对象。
-  Query:数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类来传输。
-  POJO：简单无规则java对象
   纯的传统意义的java对象，最基本的Java Bean只有属性加上属性的get和set方法可以额转化为PO、DTO、VO；比如POJO在传输过程中就是DTO
-  PO：持久层对象
   是ORM(Objevt Relational Mapping)框架中Entity，PO属性和数据库中表的字段形成一一对应关系
   VO和PO，都是属性加上属性的get和set方法；表面看没什么不同，但代表的含义是完全不同的

## 架构解决方案

### 用户界面、表现层

负责向用户战羡信息以及解释用户命令

### 应用层

很薄的一层，用来协调应用的活动，它不包含业务逻辑，他不保留业务对象的状态。但它保有应用任务的进度状态

### 领域层

本层包含关于领域的信息。这是业务软件核心的所在。在这里保留业务对象的状态，对业务对象和他们状态的持久化被委托给了基础设施层

### 基础设施层

本层作为其它层的支撑库存在。它提供了层间的通信，实现对业务对象的持久化，包含对用户界面层的支撑库等作用

## 要素

### 实体(Entity) 

- 领域模型的基本元素
- 实体应该具有唯一的标识符

### 值对象(Value Object)

- 没有唯一标识符的实体
- 领域模型中是可以被共享的，他们应该是“不可变的”（只读的）
- 需要用到值对象时，可以将它的副本作为参数传递。

### 服务(Services)

- 领域中有一些行为是无法映射到具体的对象中的，我们也不能强行将其放入在某一个模型对象中，而将其单独作为一个方法又没有地方，此时就需要服务
- 服务是无状态的，对象是有状态的。所谓状态，就是对象的基本属性。服务本身也是对象，但它却没有属性（只有行为），因此说是无状态的。
- 目的就是为领域提供简单的方法

#### 特点

- a)服务中体现的行为一定是不属于任何实体和值对象的，但它属于领域模型的范围内
- b)服务的行为一定涉及其他多个对象
- c)服务的操作是无状态的

### 模块(Moudles)

- 为了组织统一的模型概念来达到减少复杂性的目的
- 模块可以提高代码质量和可维护性
- 模块应当有对外的统一接口供其他模块调用

### 聚合(Aggregates)

聚合表示一组领域对象(包括实体和值对象)，用来表述一个完整的领域概念。而每个聚合都有一个根实体，这个根实体又叫做聚合根。

### 工厂(Factory)

帮助封装复杂的对象创建过程

### 资源库Repositories

- 资源库的是封装所有获取对象引用所需的逻辑
- Repository

  - 接口应当采用领域通用语言
  - DAO是比Repository更低的一层，包含了如何从数据库中提取数据的代码。
  - Repository把ORM框架与领域模型隔离，对外隐藏封装了数据访问机制。

## 持续集成与模型一致性

### 规约(Factory)

- 规约是一种布尔断言。
- 规约是业务规则的 部分 理论上规约类中的方法只有个：isSatisfiedBy(Object obj)。
- 规约用来测试对象是否满足某种条件，用来进行对象查询，也可以作为某个对象的创建条件。

## 总结

- 领域驱动设计的核心是领域模型，这一方法论可以通俗的理解为先找到业务中的领域模型，以领域模型为中心驱动项目的开发。而领域模型的设计精髓在于面向对象分析，在于对事物的抽象能力，一个领域驱动架构师必然是一个面向对象分析的大师。
- 在面向对象编程中讲究封装，讲究设计低耦合，高内聚的类。而对于一个软件工程来讲，仅仅只靠类的设计是不够的，我们需要把紧密联系在一起的业务设计为一个领域模型，让领域模型内部隐藏一些细节，这样一来领域模型和领域模型之间的关系就会变得简单。这一思想有效的降低了复杂的业务之间千丝万缕的耦合关系。



## 用自己的话理解领域驱动模型

**领域驱动模型是一种软件设计思想，软件开发之前，对产品所属领域进行业务知识梳理，梳理过程中，我们会形成相应领域知识，使用领域知识驱动软件设计，设计相应的领域模型。**

**我们需要把紧密联系在一起的业务设计为一个领域模型，让领域模型内部隐藏一些细节，这样一来领域模型和领域模型之间的关系就会变得简单，降低了复杂业务之间的耦合关系。**

**最后用代码实现领域模型。**
